---
title: "PRULO_MedactaReport"
author: "Corey Scholes"
type: "website"
number-sections: true
number-depth: 3
date: "2025-Apr-11"
date-modified: "2025-Jul-23"
bibliography: MitekReport references.bib
format: 
  html:
    df-print: paged
    toc: true
    toc-depth: 2
    toc-location: left
    link-external-icon: true
    link-external-newwindow: true
    smooth-scroll: true
    fig_caption: yes
  pdf:
    toc: true
    colorlinks: true
    fig_caption: yes
  docx: 
    toc: true
    fig-align: center
    fig_caption: yes
editor: visual
execute:
  echo: false
  warning: false
  message: false
---

# Preamble

**Author:** Corey Scholes, EBM Analytics

**Sponsors:** Assoc Prof Kevin Eng and Prof Richard Page, Geelong Orthopaedics

**EBMAReference**: RC_MedactaReporting_KE010Sep25

**Version:** 1.0

# Introduction

The surgeons from Geelong Orthopaedics participating in the Patient Registry of Upper Limb Pathology Outcomes (PRULO) specialise in joint replacement, sports injuries, upper limb and hand surgery, and trauma. The PRULO registry collates and stores patient outcomes collected routinely as part of the standard clinical pathway for upper limb pathology treatment.

The registry comprises three patient cohorts: rotator cuff pathology, glenohumeral instability, and general shoulder pathologies. Outcomes data collected by the registry include objective joint function, patient reported outcomes (pain, satisfaction, quality of life), radiological findings, surgical treatment and rates of revision surgery or complications.



The dataset is derived from the PRULO registry snapshot and live database tables. A [protocol](https://academic.oup.com/jsprm/article/2023/4/snad014/7317733) has been previously prepared for the registry @scholes2023.



# Glossary

To clarify terms used throughout the report, a glossary is presented below.

::: {#tbl-glossary}
+--------------------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| Term                     | Definition                                                                                                                                                                                                                                                                           |
+==========================+======================================================================================================================================================================================================================================================================================+
| Case Failure             | Patient presents in a state such that                                                                                                                                                                                                                                                |
|                          |                                                                                                                                                                                                                                                                                      |
|                          | i\) a repaired construct is deemed to be absent healing, or has reinjured subsequent to the index procedure                                                                                                                                                                          |
|                          |                                                                                                                                                                                                                                                                                      |
|                          | ii\) the shoulder presents in a state such that removal of hardware or procedure revision (single or multi-stage) is recommended                                                                                                                                                     |
+--------------------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| Reoperation              | A theatre procedure subsequent to the index surgery that does not involve removal, replacement or modification of the construct.                                                                                                                                                     |
+--------------------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| Case                     | A definitive reconstruction procedure performed on a patient, excluding a reoperation, but including revision procedures.                                                                                                                                                            |
+--------------------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| Revision Else            | A repeat definitive procedure performed on a case where the previous definitive procedure has been performed by another surgeon                                                                                                                                                      |
+--------------------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| Revision Own             | A repeat definitive procedure performed on a case where the previous definitive procedure has been performed by the same contributing surgeon                                                                                                                                        |
+--------------------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| QuickDASH                | Short form of the Disabilities of the Arm, Hand and Shoulder questionnaire. The questions are directed toward pain and disability associated with upper limb activities. A diminishing score over time reflects improved function.                                                   |
+--------------------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| WORCNorm                 | Western Ontario Rotator Cuff Index is a questionnaire specific to rotator cuff pathology and is scored as the sum of a series of 10mm visual analogue scales. A normalised score is calculated to convert the sum to a percentage score of normal (100%).                            |
+--------------------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| WORC Physical Question 3 | Question 3 of the Physical subscale of the WORC asks "How much weakness do you experience in your shoulder?" and is a                                                                                                                                                                |
+--------------------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| WOSINorm                 | Western Ontario Rotator Cuff Index is a questionnaire specific to glenohumeral instability and associated pathology and is scored as the sum of a series of 10mm visual analogue scales. A normalised score is calculated to convert the sum to a percentage score of normal (100%). |
+--------------------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+

Glossary of terms used in report
:::

# Data Preparation

The steps below outline the process for preparing registry data for analysis.

## Load libraries

Load up required packages in advance.

```{r}
#| label: Load packages

 if(!require("pacman")) install.packages("pacman")
pacman::p_load(
  "binom",
  "knitr",
  "cardx",
  "quarto",
  "pROC",
  "reshape",
  "future",
  "furrr",
  "memoise",
  "gargle",
  "googledrive",
  "googlesheets4",
  "openxlsx2",
  "readr",
  "purrr",
  "tidyverse",
  "tidymodels",
  "tidytext",
  "stopwords",
  "tictoc",
  "lubridate",
  "forcats",
  "gt",
  "consort",
  "gtsummary",
  "flextable",
  "survival",
  "ggplot2",
  "ggdist",
  "ggsurvfit",
  "ggfortify",
  "mice",
  "marginaleffects",
  "patchwork",
  "naniar",
  "quantreg",
  "broom",
  "broom.helpers",
  "labelled",
  "epoxy",
  "broom.mixed",
  "lme4",
  "janitor",
  "progressr",
  "DT",
  install = TRUE,
  update = FALSE
)

```

## Authorisations

Pre-authorise access to registry datasets.

```{r}
#| label: Authorisations
#| echo: false

options(
  gargle_oauth_cache = ".secrets",
  gargle_oauth_email = TRUE
)

drive_auth(cache = ".secrets", email = TRUE)

```

## Functions for Processing

Include a series of functions to call later in the file for processing data imports.

```{r}
#| label: Snapshot-folder
#| echo: false

base_folder_id1 <- "1og1hWKEXFcy8v8pLSzA_Ii767bbCe_EK"


```

```{r}
#| label: Retrieve-snapshot


get_latest_snapshot <- function(base_folder_id = base_folder_id1) {
  tryCatch({
    # List all folders in the base directory
    folders <- googledrive::drive_ls(as_id(base_folder_id), pattern = "^\\d{8}$")
    
    if(nrow(folders) == 0) {
      stop("No dated folders found")
    }
    
    # Sort folders by name (date) in descending order
    latest_folder <- folders[order(folders$name, decreasing = TRUE),][1,]
    
    # Find the snapshot file in the latest folder
    snapshot_file <- googledrive::drive_ls(
      latest_folder$id, 
      pattern = "Registry data snapshot\\.xlsx$"
    )
    
    if(nrow(snapshot_file) == 0) {
      stop("No snapshot file found in latest folder")
    }
    
    # Return both pieces of information as a list
    return(list(
      snapshot = snapshot_file,
      folder_name = latest_folder$name
    ))
    
  }, error = function(e) {
    stop(paste("Error finding latest snapshot:", e$message))
  })
}
```

```{r}
# Function to generate multiple dataframe pairs from a configuration list
Generate_selectrep <- function(config_list, ProductTable, SnapshotComb4, 
                               ComplicInfection, ComplicLigament_Tendon, 
                               ComplicStiffness, ComplicLoosening, ComplicHardware, 
                               ComplicInstability, ComplicNeurological, ComplicFracture,
                               ComplicThrombosis, ComplicEffusion, ComplicPain, 
                               ComplicOther, ComplicIntraop, ComplicReop, ComplicTable3, 
                               ...) {
  
  result_list <- list()
  
  for(i in seq_along(config_list)) {
    config <- config_list[[i]]
    df_name <- names(config_list)[i]
    
    # Prepare PROM arguments if specified
    prom_args <- list()
    if (!is.null(config$proms)) {
      dots <- list(...)
      for (prom_name in config$proms) {
        if (prom_name %in% names(dots)) {
          prom_args[[prom_name]] <- dots[[prom_name]]
        }
      }
    }
    
    # Create the dataframe pair with subsets and PROMs
    df_results <- do.call(create_dataframe_pair, c(
      list(
        df_name = df_name,
        category = config$category,
        search_terms = config$search_terms,
        pattern = config$pattern,
        subsets = config$subsets,
        proms = config$proms,
        ProductTable = ProductTable,
        SnapshotComb4 = SnapshotComb4,
        ComplicInfection = ComplicInfection,
        ComplicLigament_Tendon = ComplicLigament_Tendon,
        ComplicStiffness = ComplicStiffness,
        ComplicLoosening = ComplicLoosening,
        ComplicHardware = ComplicHardware,
        ComplicInstability = ComplicInstability,
        ComplicNeurological = ComplicNeurological,
        ComplicFracture = ComplicFracture,
        ComplicThrombosis = ComplicThrombosis,
        ComplicEffusion = ComplicEffusion,
        ComplicPain = ComplicPain,
        ComplicOther = ComplicOther,
        ComplicIntraop = ComplicIntraop,
        ComplicReop = ComplicReop,
        ComplicTable3 = ComplicTable3
      ),
      prom_args
    ))
    
    # Store main dataframes
    result_list[[paste0("RefCode", i)]] <- df_results$RefCode
    result_list[[paste0("SelectRep", i)]] <- df_results$SelectRep
    
    # Store PROMs
    if (!is.null(config$proms)) {
      for (prom_name in config$proms) {
        if (prom_name %in% names(df_results)) {
          result_list[[paste0("SelectRep", i, prom_name)]] <- df_results[[prom_name]]
        }
      }
    }
    
    # Store subsets with appropriate naming
    if (!is.null(config$subsets)) {
      for (subset_name in names(config$subsets)) {
        # Main subset
        if (subset_name %in% names(df_results)) {
          result_list[[paste0("SelectRep", i, subset_name)]] <- df_results[[subset_name]]
        }
        
        # PROM subsets
        if (!is.null(config$proms)) {
          for (prom_name in config$proms) {
            prom_subset_name <- paste0(subset_name, prom_name)
            if (prom_subset_name %in% names(df_results)) {
              result_list[[paste0("SelectRep", i, prom_subset_name)]] <- df_results[[prom_subset_name]]
            }
          }
        }
      }
    }
  }
  
  return(result_list)
}
```



## Import Inputs

Data was imported from the PRULO registry. Configuration tables were also loaded, including the product table to describe the products of interest and list identifiers to match to surgical records. The table was modified to include a material column (PEEK or BR) and product identifiers.

```{r}
#| label: Specify-sources
#| echo: false

SheetIDs <- list(
  DbPRULO = "https://docs.google.com/spreadsheets/d/1zyFuf0Wmij13ELTYNmdi_BprF8hU4QSCPsNZ0EYRXzo/edit",
  ProductTable = "https://docs.google.com/spreadsheets/d/1MvT00sc8FzH5SXEi-yzEgW1H1ao3AOoakKqpg7UkxW4/edit",
  RefIgnore =   "https://docs.google.com/spreadsheets/d/1MvT00sc8FzH5SXEi-yzEgW1H1ao3AOoakKqpg7UkxW4/edit",
  PROMsMaster = "https://docs.google.com/spreadsheets/d/1zyFuf0Wmij13ELTYNmdi_BprF8hU4QSCPsNZ0EYRXzo/edit",
  TargetTerms = "https://docs.google.com/spreadsheets/d/1ESVvSKAv8ma11kri9pby6OEU9Gk5Z3UnF6XwjXBTcTg/edit",
  AuditResults = "https://docs.google.com/spreadsheets/d/1GyHw8hyyOcqkSzxlQL_hlxyvFR_a1jS3LzYc2B_y_fA/edit",
  AuditReport = "https://docs.google.com/spreadsheets/d/1ESVvSKAv8ma11kri9pby6OEU9Gk5Z3UnF6XwjXBTcTg/edit"
  
)

```

```{r}
#| label: Read-live-tables

# Authenticate for sheets using the same token
gs4_auth(token = drive_token())

ComplicTable <- googlesheets4::read_sheet(
  ss = SheetIDs$DbPRULO,
  sheet = "Complications",
  range = "A1:H",
  col_names = TRUE,
  col_types = "TcccDccD"
  )

PatientTable <- googlesheets4::range_read(
  ss = SheetIDs$DbPRULO,
  sheet = "Patient",
  col_names = c(
  "PatientCreationDate",
  "PatientID",
  "LastName",
  "FirstName",
  "AlternateID",
  "DateOfBirth",
  "Sex",
  "RegistryStatus",
  "RegistryStatusNotes",
  "DateRegistryStatus",
  "NotificationMethod",
  "NoTreatmentRecords",
  "Email",
  "Phone",
  "Postcode",
  "PatientRegistrationStatus",
  "DatePatientRegistration",
  "TrueNoTreatmentRecords"
),
range = "A6:R",
col_types = "DccccDcccTciccccTi"
)


# Read RefIgnore from the specified URL and sheet. It reads only a range of 'A1:A' from the sheet 'RefIgnore'.
# Since only one column is being read, it automatically infers that all entries are of type 'character'.
RefIgnore <- googlesheets4::range_read(
ss = SheetIDs$RefIgnore,
sheet = "RefIgnore",
range = "A1:A",
col_names = TRUE,
col_types = "c"
)

# Read PROMsMaster from the specified URL and sheet. It reads a range of 'D1:H' from the sheet 'PROMS Master list'.

PROMsMaster <- googlesheets4::range_read(
  ss = SheetIDs$PROMsMaster,
  sheet = "PROMS Master list",
  range = "D1:H",
  col_names = TRUE,
  col_types = "Dcicc") |> dplyr::select(-`External Reference`)



# read in existing Procedure Terms

TargetTerms2 <- googlesheets4::range_read(
  ss= SheetIDs$TargetTerms,
  sheet = "Procedures",
  range = "A1:C",
  col_names = TRUE,
  trim_ws = TRUE
) 
```

```{r}
#| label: Import-snapshot

# Get the latest snapshot file
latest_snapshot <- get_latest_snapshot()
# 
# You can then use these in your subsequent code:
temp_file <- tempfile(fileext = ".xlsx")
drive_download(
  file = latest_snapshot$snapshot$id,
  path = temp_file,
  overwrite = TRUE
)

SnapshotGen <- openxlsx2::read_xlsx(
  temp_file,
  sheet = "ShoulderGeneral",
  colNames = TRUE,
  detectDates = TRUE
  ) |> dplyr::mutate(
    Cohort = "General",
    across(starts_with("IC"),as.character)
  )

SnapshotRC <- openxlsx2::read_xlsx(
  temp_file,
  sheet = "RotatorCuff",
  colNames = TRUE,
  detectDates = TRUE
  ) |> dplyr::mutate(
    Cohort = "Rotator Cuff",
    across(starts_with("IC"),as.character)
  )

SnapshotGHI <- openxlsx2::read_xlsx(
  temp_file,
  sheet = "GlenohumeralInstability",
  colNames = TRUE,
  detectDates = TRUE
  ) |> dplyr::mutate(
    Cohort = "Glenohumeral Instability",
    across(starts_with("IC"),as.character)
  )

STROBEInput <- openxlsx2::read_xlsx(
  temp_file,
  sheet = "Strobe_Input",
  colNames = TRUE,
  detectDates = TRUE
  ) |> dplyr::mutate(
    Cohort = "Glenohumeral Instability"
  )

```

```{r}
#| label: Coerce-date

SnapshotDate <- lubridate::ymd(latest_snapshot$folder_name)

```

```{epoxy}
#| label: Declare-date

The snapshot date was {# Format to desired format using format()
FormattedDate <- format(SnapshotDate, "%d-%b-%Y")} and the report prepared {format(today(), "%d-%b-%Y")}. The imported data contains a dataframe of {nrow(SnapshotRC)} cases returned from the Rotator Cuff cohort, a dataframe of {nrow(SnapshotGHI)} cases returned from the Glenohumeral Instability cohort and a dataframe of {nrow(SnapshotGen)} cases from the General cohort. An additional dataframe was retrieved of {nrow(STROBEInput)} cases to generate the STROBE flow chart from the PRULO registry. 

```

## Combine and Filter for 3 month follow up

The dataset was filtered to only include records with a minimum of 3 months follow up at the time of analysis.

```{r}
## Slice inputs for columns and rows
#| label: Slice-stack-1
#| code-summary: "line up input frames"
#| warning: false

# Combine SnapshotRC, SnapshotGH, and SnapshotGen into a single table.
# Remove 'ExternalStudyTag', 'Email', and 'Phone' columns.
SnapshotComb <- SnapshotRC |> dplyr::select(-(c(ExternalStudyTag,Email,Phone))) |> 
  # Combine 'SnapshotGH' and 'SnapshotGen' tables with 'SnapshotRC' table by removing the specified columns.
  bind_rows(dplyr::select(SnapshotGHI, -(c(ExternalStudyTag,Email,Phone)))) |> 
  # Continue to combine tables by removing the specified columns. This time, combining 'SnapshotGen'.
  bind_rows(dplyr::select(SnapshotGen, -(c(ExternalStudyTag,Email,Phone)))) |> 
  # Create a new column 'PatientID' based on the TreatmentID column, using 'str_split_i' function with a pattern of '.'. This means splitting the string at the first occurrence of '.', and capturing the first part (using `1` argument).
  mutate(
        PatientID = str_split_i(TreatmentID,"\\.",1)
      ) |> 
  # Move 'PatientID' column before 'TreatmentID' column.
  relocate(
    PatientID, .before = TreatmentID
  ) |> 
  # Create a new column 'CombID' by pasting 'PatientID' and 'AffectedSide' columns.
  mutate(
    CombID = paste0(PatientID,AffectedSide)
  ) |> 
  # Move 'CombID' column after 'TreatmentID' column.
  relocate(
    CombID, .after = TreatmentID
  ) |> 
  # Move 'Cohort' column to the desired position in the table.
  relocate(
    Cohort, .before = EligibleAtPreop
  ) |> mutate(
  DurationTotal = as.numeric(as.duration(interval(ymd(DateTreatment), SnapshotDate)),"days")
  ) 

# Pause this filter - filter the index procedures with this, not the revisions
# |> filter(
#     DurationTotal > 89
#   )

```

## Prepare dataset for procedure

Procedure data was combined from all cohorts. New columns were created based on conditional statements, cases were filtered where procedure data was unavailable (non-surgical, missing intraoperative data). Procedure data was further processed to standardise labels, categorised by structure (Rotator Cuff, Labrum, Capsule and Ligament) and adjunct procedures reorganised to account for variation across surgical indication.

```{r}
#| label: snapshot-comb1

SnapshotComb1  <- SnapshotComb |> 
  # Use 'case_when' function to create CuffRepair2 column
  mutate(
    CuffRepair2 = case_when(
      CuffRepair == "Yes" ~ "Rotator Cuff Repair",  
      .default = NA_character_
    ),
    # Use 'str_detect' and 'str_to_lower' functions to create TreatmentGlenoid2 column
    TreatmentGlenoid2 = case_when(
      str_detect(str_to_lower(TreatmentGlenoid), "internal fixation") ~ "Glenoid internal fixation",
      !is.na(TreatmentGlenoid) & (TreatmentGlenoid != "None" | TreatmentGlenoid != "Internal fixation") ~ TreatmentGlenoid,
      .default = NA_character_
    ),
    # Use 'case_when' function to create AdjunctProcedures2 column
    AdjunctProcedures2 = case_when(
      !is.na(AdjunctProcedures) & AdjunctProcedures != "None performed" ~ AdjunctProcedures,
      .default = NA_character_
    )
  ) |> 
  # Use 'unite' function to concatenate the new columns into a single column called Procedures2
  unite(
    "Procedures2", 
    all_of(c(
      "CuffRepair2",
      "TreatmentGlenoid2",
      "TreatmentHumeralHead",
      "SoftTissueProcedure",
      "AdjunctProcedures2",
      "ProceduresOfInterest"
    )),
    sep = "; ", 
    remove = FALSE, 
    na.rm = TRUE
  ) |> 
  # Use 'relocate' function to move the Procedures2 column to the end of the dataframe
  relocate(
    Procedures2, 
    .after = last_col()
  ) |> dplyr::select(
    -CuffRepair
  )
```

```{r}
#
SnapshotCombProc <- SnapshotComb1  |> 
  # Use the 'filter' function from dplyr to apply a filter condition to the dataframe
  filter( 
    str_length(Procedures2)  > 0
  )
```

```{r}


# This code chunk uses the `unnest_regex` function from the tidytext package to expand and transform the Procedures2 column in the SnapshotCombProc dataframe
# The goal of this operation is likely to extract individual procedures from a comma-separated or semicolon-separated string, and create new rows for each procedure
# The input pattern specifies how to split the Procedures2 column into separate procedures

ProcedureMaster   <- tidytext::unnest_regex( 
  # Select specific columns from SnapshotCombProc dataframe
  SnapshotCombProc  |> dplyr::select(
    TreatmentID, 
    CombID, 
    DateTreatment, 
    AffectedSide, 
    TreatmentStatus, 
    TreatmentStatusNotes,
    Procedures2
   ),
  
  # Specify the output column name and the input column name
  output = Procedures3, 
  input = Procedures2,

  # Regular expression pattern to split the Procedures2 column into separate procedures
  pattern = "\\; |\\, |\\band\\b |\\+", 

  # Convert all procedure names to lowercase for consistency
  to_lower = TRUE,
  
  # Do not drop any rows during the transformation
  drop = FALSE
)
```

```{r}

# This code chunk selects and transforms the ProcedureMaster dataframe to create a new TargetTerms dataframe
# The goal of this operation is to identify unique target procedures (Procedures3) for each treatment UID, and store them in a Google Sheet

TargetTermsNew    <- ProcedureMaster |> 
  # Select only TreatmentID and Procedures3 columns
  dplyr::select(
    TreatmentID,
    Procedures3
  )   |> 
  # Remove duplicate rows while keeping all other columns (TreatmentID) using distinct()
  distinct(
    Procedures3, 
    .keep_all = TRUE
  )   |> 
  # Arrange the procedures in alphabetical order within each treatment UID
  arrange(
    Procedures3
  )   |> 
  # Use str_squish() to remove extra whitespace from procedure names
  mutate(
    Procedures3  = str_squish(Procedures3)
  )

# Commented out code: This is a call to the googlesheets4 package to write the TargetTerms dataframe to a Google Sheets spreadsheet

#googlesheets4::range_write(
#  ss = "https://docs.google.com/spreadsheets/d/1ESVvSKAv8ma11kri9pby6OEU9Gk5Z3UnF6XwjXBTcTg/edit", 
#  data = TargetTerms |> dplyr::select(TreatmentID, Procedures3), 
#  sheet = "Procedures", 
#  range = paste0("A1:", "B", nrow(TargetTerms) + 1),
#  col_names = TRUE
#)
```

```{r}
#| label: Procedure-master

# Create a new dataset by joining ProcedureMaster with TargetTerms2 on Procedures3
ProcedureMaster1 <- ProcedureMaster |> left_join(
  TargetTerms2 |> dplyr::select(-TreatmentID),
  by = "Procedures3",
  relationship = "many-to-many"
  ) |> 
  
  # Filter out rows with NA values in ReplaceProcedure and rows where ReplaceProcedure is "none"
  filter(!is.na(ReplaceProcedure), !(ReplaceProcedure == "none")) |> 
  
  # Group the data by TreatmentID
  group_by(TreatmentID) |> 
  
  # Remove duplicates while keeping all columns (including non-unique ones)
  distinct(ReplaceProcedure, .keep_all = TRUE) |> 
  
  # Filter out rows where ReplaceProcedure contains certain strings
  filter(str_detect(ReplaceProcedure, "slap|bankart|augment*", negate = TRUE)) |> 
  
  # Create a new column called Entry and order the data by this column
  mutate(Entry = str_order(ReplaceProcedure)) |> 
  
  # Arrange the data in descending order of Entry within each group
  arrange(desc(Entry), .by_group = TRUE) |> 
  ungroup()


# Create a new dataset by joining ProcedureMaster with TargetTerms2 on Procedures3
ProcedureMaster1a <- ProcedureMaster |> 
  left_join(
    TargetTerms2 |> dplyr::select(-TreatmentID),
    by = "Procedures3",
    relationship = "many-to-many"
  ) |> 
  
  # Filter out rows with NA values in ReplaceProcedure and rows where ReplaceProcedure is "none"
  filter(!is.na(ReplaceProcedure), !(ReplaceProcedure == "none")) |> 
  
  # Group the data by TreatmentID
  group_by(TreatmentID) |> 
  
  # Remove duplicates while keeping all columns (including non-unique ones)
  distinct(ReplaceProcedure, .keep_all = TRUE) |> 
  
  # Create a new column called Entry and order the data by this column
  mutate(Entry = str_order(str_sort(ReplaceProcedure))) |> 
  
  # Arrange the data in descending order of Entry within each group
  arrange(desc(Entry), .by_group = TRUE) |> 
  ungroup()
  

```

```{r}
#| label: fig-ProcedureCount
#| fig-cap: "Summary of procedure terms included in registry output"

# Create a new dataset by grouping ProcedureMaster1 by ReplaceProcedure and counting the occurrences
FigProcCount  <- ProcedureMaster1  |> 
  
   # Count the occurrences of each unique value in ReplaceProcedure, sort the results by count in ascending order (default), and create a new dataset
  count(ReplaceProcedure, sort = TRUE)  |> 
  
   # Filter out procedures with only one occurrence
  filter(n > 1)  |> 
  
   # Create a new column called ReplaceProcedure and reorder it based on the count of each procedure
  mutate(ReplaceProcedure = reorder(ReplaceProcedure, n))  |> 
  
   # Create a bar plot using ggplot2, where x-axis is the count (n) and y-axis is the reorder(replaceprocedure) variable
  ggplot(aes(n, ReplaceProcedure)) + 
  
   # Add a geom_col() layer to create the bar plot
  geom_col() + 
  
   # Remove the axis label for the y-axis using labs()
  labs(y = NULL)
  
  # Print the plot using knit_print from knitr package
knitr::knit_print(FigProcCount)
```

```{r}

# This is a data cleaning and processing script using the dplyr package in R. The script is designed to extract specific information from a column called Procedure4, which seems to contain descriptions of surgical procedures.

# Here's a high-level overview of what the script does:
# # 
# It creates new columns based on conditions detected in Procedure4. These conditions include:
# Rotator cuff repair and augmentation
# Long head biceps tendon repair, transfer, or tenotomy
# Labrum repair, debridement, or capsulolabral reconstruction
# Capsule ligament repair, release, or reconstruction
# Glenoid procedures (e.g., glenoplasty, Bristow, fixation)

# The script uses various str_detect and case_when functions to detect specific patterns in the Procedure4 column and assign corresponding values to the new columns.
# 
# Some conditions have multiple possible outcomes depending on the presence or absence of certain words or phrases in the Procedure4 description.

# Goal: Create a new data frame (ProcedureMaster2) that combines information from 
#       SnapshotComb1b and ProcedureMaster1a, and updates the RepairAugmentation column
#       to reflect more detailed information about augmentations in the Procedure4 column

ProcedureMaster2 <- left_join(
  # Filter SnapshotComb1 to only include rows with SurgicalTreatment == "Surgical"
  SnapshotComb1 |> filter(SurgicalTreatment == "Surgical") |>
  
  # Select specific columns from the filtered data frame
  dplyr::select(TreatmentID, CuffRepair2, AdjunctProcedures2, SoftTissueProcedure, RepairAugmentation, ProceduresOfInterest),
  
  # Summarize ProcedureMaster1a by TreatmentID and collapse unique ReplaceProcedure values into a single string separated by ";"
  summarise(ProcedureMaster1a, 
             .by = "TreatmentID", 
             Procedure4 = str_c(str_unique(ReplaceProcedure), collapse = "; ")
  ),
  
  # Specify the join relationship as one-to-one
  by = "TreatmentID",
  relationship = "one-to-one"
) |> 
  
#   This code chunk is building upon the previous one by continuing to transform and clean the `RepairAugmentation` column in the `ProcedureMaster2` data frame.
# 
# Here's a breakdown of what each line does:
# 
# 1. The first `mutate` statement creates a new column called `RepairAugmentation2`, which uses a series of conditional statements (`case_when`) to update the values in the original `RepairAugmentation` column based on conditions in the `Procedure4` column.
# 
#    - If `RepairAugmentation` is not NA or "Other" and `Procedure4` does not contain "augment*", then set `RepairAugmentation2` equal to the original value.
#    - If `RepairAugmentation` is NA or "Other" and `Procedure4` contains "augment*", then extract the text that follows "rotator cuff repair augmentation" (using a regular expression) and store it in `RepairAugmentation2`.
#    - If `RepairAugmentation` is not NA or "Other" and `Procedure4` contains "augment*", then concatenate the original value with the extracted text (from step 2) separated by "; ", and store the result in `RepairAugmentation2`.
# 
# 2. The second `mutate` statement creates a new column called `RepairAugmentation3`, which uses another series of conditional statements (`case_when`) to further transform the values in `RepairAugmentation2`. This includes:
#    - Replacing specific text patterns (e.g., "rotator cuff repair augmentation  - biceps") with alternative text ("Autograft").
#    - Replacing another specific text pattern (e.g., "rotator cuff repair augmentation  - superior capsular reconstruction") with a simpler term ("Superior Capsular").
#    - Adding the text "advancement" to `RepairAugmentation2` if it contains "advancement".
#    - Otherwise, just copying the original value.
# 
# 3. The third `mutate` statement creates a new column called `RepairAugmentationClean`, which uses yet another series of conditional statements (`case_when`) to clean up the values in `RepairAugmentation3`. This includes:
#    - Replacing a specific text pattern (e.g., "Superior Capsular; Superior Capsular") with a simpler term ("Superior Capsular").
#    - Setting "Nil" to "None" if that's what `RepairAugmentation3` is.
#    - Otherwise, just copying the original value.
# 
# These transformations aim to improve the readability and consistency of the data in the `RepairAugmentation` column.
  
  mutate(
  # Update RepairAugmentation column based on conditions in Procedure4 column
  RepairAugmentation2 = case_when(
    (!(is.na(RepairAugmentation)) | RepairAugmentation == "Other") & !str_detect(Procedure4, "augment*") ~ RepairAugmentation,
    (is.na(RepairAugmentation) | RepairAugmentation == "Other") & str_detect(Procedure4, "augment*") ~ str_extract(Procedure4, "rotator cuff repair augmentation\\s+([^;]+)"),
    (!(is.na(RepairAugmentation)) | RepairAugmentation != "Other") & str_detect(Procedure4, "augment*") ~ str_c(RepairAugmentation, str_extract(Procedure4, "rotator cuff repair augmentation\\s+([^;]+)"), sep = "; ")
  )
) |> mutate(
  RepairAugmentation3 = case_when(
    str_detect(RepairAugmentation2,"rotator cuff repair augmentation - biceps") ~ str_replace(RepairAugmentation2,"rotator cuff repair augmentation - biceps", "Autograft"),
        str_detect(RepairAugmentation2,"rotator cuff repair augmentation - superior capsular reconstruction") ~ str_replace(RepairAugmentation2,"rotator cuff repair augmentation - superior capsular reconstruction", "Superior Capsular"),
    str_detect(Procedure4,"advancement") ~ str_c(RepairAugmentation2,"advancement",sep = "; "),
    .default = RepairAugmentation2
    )
  ) |> mutate(
    RepairAugmentationClean = case_when(
      str_detect(RepairAugmentation3,"Superior Capsular; Superior Capsular") ~ str_replace(RepairAugmentation3,"Superior Capsular; Superior Capsular","Superior Capsular"),
      RepairAugmentation3 == "Nil" ~ "None",
      .default = RepairAugmentation3
      )
    ) |> mutate(
      CuffRepair = case_when(
        !is.na(RepairAugmentationClean) & RepairAugmentationClean != "None" & str_detect(Procedure4,"rotator cuff repair") ~ "Augmented Cuff Repair",
        (is.na(RepairAugmentationClean) | RepairAugmentationClean == "None") & str_detect(Procedure4,"rotator cuff repair") ~ "Cuff Repair",
        str_detect(Procedure4,"remplissage") ~ "Remplissage",
        !is.na(Procedure4) & str_detect(Procedure4, "(rotator cuff repair)|remplissage", negate = TRUE) ~ "None",
        .default = NA_character_
      ),
      LongHeadBiceps = case_when(
        str_detect(Procedure4,"biceps tenodesis") ~ "Tenodesis",
        str_detect(Procedure4,"biceps transfer") ~ "Transfer",
        str_detect(Procedure4, "tenotomy") ~ "Tenotomy",
        str_detect(Procedure4, "long-head") ~ "Unknown",
        !is.na(Procedure4) & str_detect(Procedure4, "(biceps)(tenotomy|transfer|tenodesis)", negate = TRUE) ~ "None",
        .default = NA_character_
      ),
      Labrum = case_when(
        str_detect(Procedure4,"labrum repair") ~ "Labrum Repair",
        str_detect(Procedure4,"labrum debridement") ~ "Debridement",
        str_detect(Procedure4, "capsulolabral") ~ "Capsulolabral Repair",
        !is.na(Procedure4) & str_detect(Procedure4, "((labrum repair)|debridement)|capsulolabral", negate = TRUE) ~ "None",
        .default = NA_character_
      ),
            LabrumRepair = case_when(
        str_detect(Procedure4,"bankart") ~ "Bankart",
        str_detect(Procedure4,"slap") ~ "SLAP",
        str_detect(Procedure4,"labrum repair") & str_detect(Procedure4, "bankart|slap", negate = FALSE) ~ "Other",
        !is.na(Procedure4) & str_detect(Procedure4, "((labrum repair)|debridement)|capsulolabral", negate = TRUE) ~ "None",
        .default = NA_character_
      ),
      CapsuleLigament = case_when(
        str_detect(Procedure4,"shift") ~ "Capsular Shift",
        str_detect(Procedure4,"(ligament|avulsion) repair") ~ "Repair",
        str_detect(Procedure4,"ligament (debulk|release|debridement)") ~ "Ligament Release",
        str_detect(Procedure4, "capsulotomy") ~ "Capsulotomy",
        str_detect(Procedure4, "capsular reconstruction") | str_detect(RepairAugmentationClean, "Capsular") ~ "Capsular Reconstruction",
        str_detect(Procedure4, "other soft tissue") ~ "Other",
        !is.na(Procedure4) & str_detect(Procedure4, "shift|capsulotomy|release|soft((ligament|avulsion)(repair))", negate = TRUE) & str_detect(RepairAugmentationClean, "Capsular", negate = TRUE) ~ "None",
        .default = NA_character_
      ),
      Glenoid = case_when(
        str_detect(Procedure4,"glenoplasty") ~ "Glenoplasty",
        str_detect(Procedure4,"bristow") ~ "Bristow",
        str_detect(Procedure4,"fixation") & str_detect(Procedure4,"humeral fracture", negate = TRUE) ~ "Fracture fixation",
        str_detect(Procedure4,"latarjet") ~ "Latarjet",
        !is.na(Procedure4) & (str_detect(Procedure4, "glenoplasty|fixation|latarjet|bristow", negate = TRUE) | str_detect(Procedure4,"humeral fracture")) ~ "None",
        .default = NA_character_
      )
      )
```

```{r}

# Filter out adjunct procedures from proceduremaster and then left_join into proceduremaster2

ProcedureAdjunct <- ProcedureMaster1 |> dplyr::select(-Entry) |> filter(
  str_detect(
    ReplaceProcedure,
    "repair|remplissage|biceps|labrum|capsul*|ligament|soft|gleno*|fixation|latarjet|bristow",
    negate = TRUE)
) |> group_by(
  TreatmentID
) |> distinct(
  ReplaceProcedure,
  .keep_all = TRUE
) |> mutate(
  Entry = str_order(
  ReplaceProcedure
) 
) |> arrange(
  desc(ReplaceProcedure),
  .by_group = TRUE
) |> ungroup()

```

```{r}

# Continue processing to extract out adjunct procedures and reinject back into procedures dataframe
ProcedureMaster3 <- left_join(
  ProcedureMaster2,
  summarise(
  ProcedureAdjunct,
  .by = "TreatmentID",
  AdjunctProcedure = str_c(str_unique(ReplaceProcedure), collapse = "; ")
),
by = "TreatmentID"
) |> mutate(
  AdjunctProcedure2 = stringr::str_to_title(case_when(
   if_any(CuffRepair:Glenoid,~!is.na(.)) & is.na(AdjunctProcedure) ~ "None", 
    if_all(CuffRepair:Glenoid,~is.na(.)) ~ NA_character_,
    .default = AdjunctProcedure
  )
)
) |> mutate(
  across(
    c(
      CuffRepair,
      LongHeadBiceps,
      Labrum,
      CapsuleLigament
      ),
      ~ifelse(. == "None", NA, .))
  ) |> unite(
    "ProcedureTotal",
    c(CuffRepair, LongHeadBiceps, Labrum, CapsuleLigament),
    na.rm = TRUE,
    sep = "; ",
    remove = FALSE
    ) |> mutate(
      ProcedureTotal = ifelse(ProcedureTotal == "", "None", ProcedureTotal)
  ) |> dplyr::select(
  -(c(
    AdjunctProcedure,
    RepairAugmentation,
    RepairAugmentation2,
    RepairAugmentation3
  )
  )
) |> rename(
  AdjunctProcedure = "AdjunctProcedure2",
  RepairAugmentation = "RepairAugmentationClean"
) |> relocate(
  RepairAugmentation,
  .after = CuffRepair
) |> mutate( # switch back to "None" labeling for tables in each report
  across(
    c(
      CuffRepair,
      LongHeadBiceps,
      Labrum,
      CapsuleLigament
      ),
      ~ifelse(is.na(.), "None", .))
  )
```

```{r}

# Marry into SnapshotComb to continue processing from one dataframe
#Adjust for labrum procedures

SnapshotComb1a <- left_join(
  SnapshotComb1 |> dplyr::select(
    -(c(
      AdjunctProcedures,
      RepairAugmentation,
      TreatmentGlenoid,
      TreatmentHumeralHead
    ))
    ),
    ProcedureMaster3 |> dplyr::select(
      TreatmentID,
      ProcedureTotal:AdjunctProcedure
    ),
    by = "TreatmentID",
    relationship = "one-to-one"
  ) |> separate_wider_delim(
  cols = LabralTearPosition,
  delim = " - ",
  names = c("TearStart","TearEnd")
) |> mutate(
  TearStart = as.numeric(TearStart),
  TearEnd = as.numeric(TearEnd),
  LabrumPath2 = case_when(
    is.na(TearStart) | is.na(TearEnd) ~ NA_character_,
    (!is.na(TearStart) & !is.na(TearEnd)) & (between(TearStart,1,6) & between(TearEnd,3.9,10)) ~ "Bankart",
    (!is.na(TearStart) & !is.na(TearEnd)) & (between(TearStart,6.1,11.9) & between(TearEnd,6.1,11.9)) ~ "Posterior",
    (!is.na(TearStart) & !is.na(TearEnd)) & (between(TearStart,9.9,12.9) | between(TearStart,0.9,2.1)) & (between(TearEnd,9.9,12.9) | between(TearEnd,0.9,2.1)) ~ "SLAP",
    .default = "Other"
  )
) |> mutate(
  LabrumRepair2 = case_when(
    str_detect(Labrum,"Repair") & LabrumPath2 == "Bankart" ~ "Bankart",
    str_detect(Labrum,"Repair") & LabrumPath2 == "SLAP" ~ "SLAP",
    str_detect(Labrum,"Repair") & LabrumPath2 == "Other" ~ "Other",
    str_detect(Labrum,"Repair") & LabrumPath2 == "SLAP" ~ "SLAP",
    str_detect(Labrum,"Repair") & LabrumPath2 == "Posterior" ~ "Posterior",
    !is.na(LabrumPath2) & (is.na(Labrum)|Labrum == "None") ~ "Not Repaired",
    .default = LabrumRepair
    )
  ) |> relocate(
  c(TearStart,TearEnd,LabrumPath2), .after = "Procedures2"
)   |> relocate(
  c(LabrumRepair2), .after = "LabrumRepair"
) |> dplyr::select(
  -LabrumRepair
) |> rename(
  LabrumRepair = "LabrumRepair2"
)
```

## Adjust dataset for time to event

To account for variations in follow up, time to event was calculated between date of surgery and change of record status. Treatment record end was defined as any change in state such that the treatment would be considered no longer active, has not achieved its clinical purpose or is no longer relevant. For example, in the case of soft tissue repair, if the target tissue represents with a retear, or the construct presents in a state such that hardware removal or replacement is recommended, then the treatment record status is set to inactive and a new treatment record is created to capture the subsequent treatment. The treatments with inactive statuses were extracted to a shared file for review. The subsequent treatment was manually labelled to create the *Subsequent Treatment* variable.

Additional numeric variables were calculated from inputs collected within the registry (e.g. Symptom Duration).

```{r}
#| label: Survival-prep-1
# create endate and survival time

#Calculate status
SnapshotComb2 <- SnapshotComb1a |> mutate(
  Status = case_when(
    TreatmentStatus == "Failed"~ 1,
    .default = 0),
  EndDate = case_when(
    !is.na(DateStatusChange) ~ DateStatusChange,
    .default = coalesce(DateStatusChange, SnapshotDate)
  ),
  Duration = as.numeric(as.duration(interval(ymd(DateTreatment), ymd(EndDate))),"weeks"),
        WaitTime = as.numeric(as.duration(interval(ymd(DateInitialExamination), ymd(DateTreatment))),"weeks"),
 CuffTearSizeML = as.numeric(CuffTearSizeML),
 CuffTearSizeAP = as.numeric(CuffTearSizeAP),
 SymptomDuration = as.numeric(as.duration(interval(ymd(DateOfInjury_Preop), ymd(DateTreatment))),"weeks"),
 SymptomDurationCat = case_when(
  is.na(SymptomDuration) ~ NA_character_,
  SymptomDuration <= 26 ~ "<=0.5",
  SymptomDuration > 26 ~ ">0.5"
) 
 )

# |> dplyr::mutate(
#   factor(levels = c("<=0.5", ">0.5"), exclude = NULL)
```

```{r}
#| eval: true

# Authenticate for sheets using the same token
gs4_auth(token = drive_token())


SnapshotCombFail <- SnapshotComb2 |> dplyr::filter(
  TreatmentStatus == "Failed",
  SurgicalTreatment == "Surgical"
)

with_gs4_quiet(googlesheets4::range_write(
  ss = SheetIDs$AuditResults,
  data = SnapshotCombFail |> dplyr::select(
    TreatmentID,
    CombID,
    DateTreatment,
    Cohort,
    TreatmentStatus,
    TreatmentStatusNotes,
    DateStatusChange
    ) |> dplyr::arrange(
     desc(DateTreatment)
    ),
  sheet = "Failures",
  range = "A1:G",
  col_names = TRUE
)
)
```

Read in results of manual review of failure cases and categorise subsequent treatments.

```{r}

SnapshotSubseq <- SnapshotComb2 |> dplyr::filter(
  CombID %in% SnapshotCombFail$CombID
) |> dplyr::select(
  TreatmentID,
  CombID,
  DateTreatment,
  TreatmentStatus,
  TreatmentStatusNotes,
  DateStatusChange,
  SurgicalTreatment
) |> dplyr::group_by(
  CombID
) |> arrange(
  CombID,
  DateTreatment,
  by_group = FALSE
)


```

```{r}
#| eval: true

# Authenticate for sheets using the same token
gs4_auth(token = drive_token())

SnapshotRevision <- googlesheets4::range_read(
  ss = SheetIDs$AuditResults,
  sheet = "Failures",
  range = "A1:I",
  col_types = "ccDcccDcc"
)

SnapshotComb2a <- left_join(
  SnapshotComb2,
  SnapshotRevision |> dplyr::select(
    TreatmentID,
    SubsequentTx
  ),
  by = "TreatmentID"
) |> mutate(
  SubsequentTx2 = case_when(
    is.na(SubsequentTx) ~ "Not Applicable",
    str_detect(SubsequentTx,"ROH") ~ str_replace_all(SubsequentTx,"ROH","Removal of Hardware"),
    str_detect(SubsequentTx,"Non-op") ~ "Nonoperative Management",
    .default = stringr::str_to_title(SubsequentTx)
  ),
    ReoperationProcedure2 = case_when(
      is.na(ReoperationProcedure) & (SubsequentTx2 == "Nonoperative Management" | SubsequentTx2 == "Not Applicable")  ~ "No",
      is.na(ReoperationProcedure) & !(SubsequentTx2 == "Nonoperative Management" | SubsequentTx2 == "Not Applicable") ~ "Yes",
      ReoperationProcedure == "No" & !(SubsequentTx2 == "Nonoperative Management" | SubsequentTx2 == "Not Applicable") ~ "Yes",
      .default = ReoperationProcedure
    )
)
```

```{r}
SnapshotCombCheck <- SnapshotComb2a |> dplyr::select(
  TreatmentID,
  Cohort,
  TreatmentStatus,
  TreatmentStatusNotes,
  ReoperationProcedure2,
  SubsequentTx
)
```



## Prepare product groups of interest

Tables were rearranged and the dataset was filtered against an ignore list created from the product configuration table. Regular expressions were used to match products of interest to intraoperative hardware information and to sum the instances of implantation for each product of interest.

```{r}
#| label: Product-usage

#Extract cases with Mitek

ProductUsage1 <- SnapshotComb2a |> dplyr::select(TreatmentID,ImplantCodes) |> dplyr::filter(stringr::str_detect(ImplantCodes,"05.10.002"))

# Trim whitespace
ProductUsage1$ImplantCodes <- trimws(ProductUsage1$ImplantCodes)

#Pivot long so each Product code is on its own row

# Link back to ProductTable and bring back model description and count models rather than SKUs
ProductUsage2 <- separate_longer_delim(
    ProductUsage1,
    cols = ImplantCodes,
    ", ") |> dplyr::filter(
      stringr::str_detect(ImplantCodes,"05.10.002")
    )
```


```{r}
ProductUsage3 <- ProductUsage2 |> summarise(
  .by = TreatmentID,
  UsageCount = n()
)
```

```{r}
#| label: master-list


MasterTable <- SnapshotComb2a |> filter(
  TreatmentID %in% ProductUsage3$TreatmentID
)


```


## Adjust patient demographics for presentation

Recode Sex for report presentation.

```{r}
MasterTable1 <- MasterTable |> mutate(
  Sex2 = case_when(
    Sex == "F" ~ "Female",
    Sex == "M" ~ "Male",
    .default = NA_character_
  )
) |> dplyr::select(-Sex) |> rename(
  Sex = "Sex2"
)
```

## Prepare Patient-Reported Outcomes

The PRULO registry uses the QuickDASH [@gummesson2006] for all cases, Western Ontario Rotator Cuff Index (WORC) [@kirkley2003] for records placed into the Rotator Cuff cohort and the Western Ontario Shoulder Instability Index (WOSI) [@kirkley1998] for records placed in the Glenohumeral Instability cohort to monitor patient-reported outcomes before and after surgery at defined time intervals. The metrics utilised for each questionnaire in this report are the total score (QuickDaSH) and the normalised total score (WORC and WOSI). A single question from the WORC was also presented (Question 3 of the Physical subscale) that asks "How much weakness do you experience in your shoulder?" to observe potential patterns relevant specifically to cuff repair. PROMs entries were restricted to cases where the treatment record was "eligible" for the time point. Tables were reshaped and variables refactored, with delta variables generated (difference to baseline at each followup) to enable plotting and table generation.

```{r}
#| label: Proms-prep
#| code-summary: "Prepare for PROMs analysis"
#| warning: false

#Add delta columns Pre-3months; Pre-6months; Pre-12months

MasterPROM <- MasterTable1 |>
  rename_with( ~sub("_TotalScore_","",.), contains("TotalScore")) |>
  rename_with( ~sub("WOSI_Norm_","WOSINorm",.), contains("WOSI_Norm")) |>
  rename_with( ~sub("WORC_Norm_","WORCNorm",.), contains("WORC_Norm")) |>
  rename_with( ~sub("PhysicalQ3_","PhysicalQ3",.), contains("PhysicalQ3")) |>
  rename_with( ~sub("EligibleAt|EligibleAtx", "Eligible",.), starts_with("EligibleAt")) |>
  mutate(
  across(matches("QDASH|WORC|WOSI"),as.numeric)
  ) |>
  dplyr::select(
    !c(
    RegistryStatus:DateOfBirth, 
    DominantSide, 
    Weight,
    Height,
    DateBMI,
    EligibleIntraop,
    RecordNumberInIntraop,
    tidyselect::ends_with("24months")
    )
    ) |>
  relocate((all_of(c("QDASHPreop",
                        "QDASH3months",
                        "QDASH6months",
                        "QDASH12months",
                        "EligiblePreop",
                        "Eligible3months",
                        "Eligible6months",
                        "Eligible12months"))), .after = last_col(),
           ) |>
mutate(
  Eligible3months = case_when(
    Eligible3months != "Yes" ~ NA_character_,
    .default = Eligible3months
  ),
  DeltaQPreop = NA,
  DeltaQ3months = case_when(
    (EligiblePreop == "Yes" & !is.na(QDASHPreop)) & (Eligible3months == "Yes" & !is.na(QDASH3months)) ~ QDASHPreop - QDASH3months,
    .default = NA
  ),
   DeltaQ6months = case_when(
    (EligiblePreop == "Yes" & !is.na(QDASHPreop)) & (Eligible6months == "Yes" & !is.na(QDASH6months)) ~ QDASHPreop - QDASH6months,
    .default = NA
  ),
   DeltaQ12months = case_when(
    (EligiblePreop == "Yes" & !is.na(QDASHPreop)) & (Eligible12months == "Yes" & !is.na(QDASH12months)) ~ QDASHPreop - QDASH12months,
    .default = NA
  ),
  WORCDeltaPreop = NA,
  WORCDelta6months = case_when(
    (EligiblePreop == "Yes" & !is.na(WORCNormPreop)) & (Eligible6months == "Yes" & !is.na(WORCNorm6months)) ~ WORCNorm6months - WORCNormPreop,
    .default = NA
  ),
   WORCDelta12months = case_when(
    (EligiblePreop == "Yes" & !is.na(WORCNormPreop)) & (Eligible12months == "Yes" & !is.na(WORCNorm12months)) ~ WORCNorm12months - WORCNormPreop,
    .default = NA
  ),
  WOSIDeltaPreop = NA,
  WOSIDelta3months = case_when(
    (EligiblePreop == "Yes" & !is.na(WOSINormPreop)) & (Eligible3months == "Yes" & !is.na(WOSINorm3months)) ~ WOSINormPreop - WOSINorm3months - WOSINormPreop,
    .default = NA
  ),
  WOSIDelta6months = case_when(
    (EligiblePreop == "Yes" & !is.na(WOSINormPreop)) & (Eligible6months == "Yes" & !is.na(WOSINorm6months)) ~ WOSINorm6months - WOSINormPreop,
    .default = NA
  ),
   WOSIDelta12months = case_when(
    (EligiblePreop == "Yes" & !is.na(WOSINormPreop)) & (Eligible12months == "Yes" & !is.na(WOSINorm12months)) ~ WOSINorm12months - WOSINormPreop,
    .default = NA
  ),
  )

```

```{r}
# Check the lengths of columns specified in varying



QDASH_cols <- grep("QDASH", colnames(MasterPROM), value = TRUE)
DeltaQ_cols <- grep("DeltaQ", colnames(MasterPROM), value = TRUE)
WORC_cols  <- grep("WORCNorm|WORCPhysicalQ3|WORCDelta", colnames(MasterPROM), value = TRUE)
WOSI_cols  <- grep("WOSINorm|WOSIDelta", colnames(MasterPROM), value = TRUE)
Eligible_cols <- grep("Eligible", colnames(MasterPROM), value = TRUE)

lengths_QDASH <- sapply(QDASH_cols, function(col) length(unique(MasterPROM$TreatmentID)))
lengths_DeltaQ <- sapply(DeltaQ_cols, function(col) length(unique(MasterPROM$TreatmentID)))
lengths_WORC <- sapply(WORC_cols, function(col) length(unique(MasterPROM$TreatmentID)))
lengths_WOSI <- sapply(WOSI_cols, function(col) length(unique(MasterPROM$TreatmentID)))

lengths_Eligible <- sapply(Eligible_cols, function(col) length(unique(MasterPROM$TreatmentID)))

```

```{r}
#| label: PROM-prep-DASHWOSI

MasterPROM1 <- MasterPROM |>
  pivot_longer(
    cols = c(
      starts_with("QDASH"),
      starts_with("DeltaQ"),
      starts_with("WOSINorm"),
      starts_with("WOSIDelta"),
      starts_with("Eligible")
    ),
    names_to = c(".value", "Timepoint"),
    names_pattern = "(.+)(Preop|3m|6m|12m)",
    values_to = c("QDASH", "QDASHDelta", "WOSINorm", "WOSIDelta", "Eligible")
  ) |>
  mutate(Timepoint = forcats::fct(
    Timepoint, 
    levels = c("Preop", "3m", "6m", "12m"))
    ) |> filter(!is.na(Eligible)) |> rename(
      QDASHDelta = "DeltaQ"
    )

```

```{r}
#| label: PROM-prep-WORC

MasterPROM2 <- MasterPROM |>
  pivot_longer(
    cols = c(
      starts_with("WORCNorm"),
      starts_with("WORCDelta"),
      starts_with("WORCPhysicalQ3"),
      starts_with("Eligible")
    ),
    names_to = c(".value", "Timepoint"),
    names_pattern = "(.+)(Preop|6m|12m)",
    values_to = c("WORCNorm","WORCDelta","WOSIPhysicalQ3", "Eligible")
  ) |>
  mutate(Timepoint = forcats::fct(
    Timepoint, 
    levels = c("Preop", "6m", "12m"))
    ) |> filter(!is.na(Eligible))

```


## Prepare adverse events

Adverse events were monitored by near real-time chart review and surgical bookings. Events were added to the registry using an electronic form and linked to the treatment records. The data import was assessed for data entry validity, differences between date of event, date of reoperation and surgery date of the index treatment were calculated to assess date validity. Additional data preparation and cleaning was performed, which included filtering and standardizing key identifiers across multiple datasets. Missing values were identified to ensure data consistency. The adverse events were attached to the treatment data with filters applied to constrain to pertinent records and time periods. Time-based metrics were calculated and classification was performed based on the event descriptions using regular expressions. Finally, it conducted data quality checks, identifying potential discrepancies and duplicate entries. After the data transformation, the revised dataset was exported to an external file for review. The code then generated multiple subset datasets, each focusing on a specific type of complication and isolating the earliest occurrence for each unique treatment. This was used for retrieval for each product report.


```{r}
#| label:  Complications-intraop
# Slice out intraoperative complications (explants)
# 
# 
IntraopComp <- MasterTable1 |> dplyr::select(
  TreatmentID,
  CombID,
  DateTreatment,
  SurgicalTreatment,
  TreatmentStatus,
  ICCount:ICIntervention
) |> filter(
  !is.na(ICCount)
) |> mutate(
  ICNature2 = if_else(
    stringr::str_detect(ICNature,"explant"),
    "Hardware explantation",
    ICNature
  )
)

```





```{r}
#| label:  Complications-postop
# Join sufficient columns to complictable to perform calculations


# Add filter to align complications table with snapshot with CurrentDate
ComplicTable1 <- ComplicTable |> dplyr::filter(
    `Date of Occurrence` < SnapshotDate
    ) |>
  mutate(
    TreatmentID = trimws(`Treatment ID`)
  )

#Tidy up TreatmentID in both tables
# Remove leading and trailing whitespaces

SnapshotComb2a$TreatmentID <- trimws(SnapshotComb2a$TreatmentID)
# Check data types
#str(ComplicTable1$TreatmentID)
#str(SnapshotComb2$TreatmentID)

#str(SnapshotComb2$DateTreatment)

# Check for NAs in ComplicTable1
na_in_ComplicTable1 <- sum(is.na(ComplicTable1$TreatmentID))


# Check for NAs in SnapshotMerge2
na_in_SnapshotComb2a <- sum(is.na(SnapshotComb2a$TreatmentID))

```



```{epoxy}
#| eval: false

There are {nrow(SnapshotComb2a |> filter(is.na(TreatmentID)))} cases with missing TreatmentID in the dataset and {nrow(ComplicTable1 |> filter(is.na(TreatmentID)))} missing in the complications table.

```

<!--# Clean up live tables for complications. Assess date validity and correct data entry. -->

```{r}
mismatched_rows <- ComplicTable1[!(ComplicTable1$TreatmentID %in% SnapshotComb2$TreatmentID), ]

# Remove non-matching rows from ComplicTable2
ComplicTable2 <- ComplicTable1 |>
  filter(!(TreatmentID %in% mismatched_rows$TreatmentID))
```

```{r}
# Join in key data from Snapshot table to calculate additional columns
ComplicTable3 <- left_join(
  ComplicTable2,
  SnapshotComb2a |> dplyr::select(
  TreatmentID,
  DateStatusChange,
  DateTreatment,
  ICCount:ICIntervention
  ),
  by = "TreatmentID"
) |> 
  filter(
    !is.na(DateTreatment) & `Complication Occurrence` != "No"
  ) |>
  mutate(
    DateOccurFix = ymd(`Date of Occurrence`),
  ) |>
mutate(
  EventDelay = as.numeric(as.duration(interval(ymd(DateTreatment), ymd(DateOccurFix))),"weeks"), # Mitek would like this in years - may need to change over once intiial review is complete
  ReopDelay_Surgery = as.numeric(difftime(`Reoperation Procedure Date`,DateTreatment,units = "weeks")),
  ReopDelay_Occur = as.numeric(difftime(`Reoperation Procedure Date`,DateOccurFix,units = "weeks")),
DateCheck = case_when(
  `Date of Occurrence` < DateTreatment ~ "Check",
  .default = "OK"
),
  Infection = case_when(
    stringr::str_detect(stringr::str_to_lower(`Complication Nature`),"washout|infect|antibiotic*|vac.*dress*|culture") ~ "Yes", #added "culture" as term for Infection
    .default = "No",
  ),
  Ligament_Tendon = case_when(
    stringr::str_detect(stringr::str_to_lower(`Complication Nature`),"fail|recurrent|rupture|retear|.*torn|weak|weakness|tear") ~ "Yes", #removed enthesopathy, as those kind of connective tissue pathologies will make it difficult to distinguish from retears in this framework - pushed to Other. 
    .default = "No"
    ),
  Stiffness = case_when(
    stringr::str_detect(stringr::str_to_lower(`Complication Nature`),"capsulitis|frozen|stiff*|release|arthrofib*") ~ "Yes", #removed "carpal tunnel release" as a term for "Stiffness" as it was previously overlapping with other types of releases
    .default = "No"
    ),
  Loosening = case_when(
   stringr::str_detect(stringr::str_to_lower(`Complication Nature`),"regraft*|loos(?!e\\sbodies)|pullout") ~ "Yes",
    .default = "No"
    ),
  Hardware = case_when(
   stringr::str_detect(stringr::str_to_lower(`Complication Nature`),"remov*|irritat*|explant*|broke*|annoy*|device|replac*") ~ "Yes", 
   .default = "No"
  ),
  Instability = case_when(stringr::str_detect(stringr::str_to_lower(`Complication Nature`),"instab*|sublux*|disloc*") ~ "Yes",
    .default = "No"
  ),
  Neurological = case_when(
    stringr::str_detect(stringr::str_to_lower(`Complication Nature`),"palsy|radiculopathy|carpal\\s+tunnel") ~ "Yes", #added carpal tunnel compression or release as a potential neurological condition
    .default = "No"
  ),
  Fracture = case_when(
    stringr::str_detect(stringr::str_to_lower(`Complication Nature`),"fract*") ~ "Yes",
    .default = "No"
  ),
  Wound = case_when(
    stringr::str_detect(stringr::str_to_lower(`Complication Nature`),"wound|necro*") ~ "Yes",
    .default = "No"
  ),
  Thrombosis = case_when(
    stringr::str_detect(stringr::str_to_lower(`Complication Nature`),"dvt|embo*|\\bpe\\b|occlus*") ~ "Yes",
    .default = "No"
  ),
  Effusion = case_when(
    stringr::str_detect(stringr::str_to_lower(`Complication Nature`),"swell*|edema|oedema|effus*|swollen") ~ "Yes",
    .default = "No"
  ),
  Pain = case_when(
    stringr::str_detect(stringr::str_to_lower(`Complication Nature`),"pain|complex|crps") ~ "Yes", #previously had word boundary - but got excluded when hard up against ";" so removed word boundaries
    .default = "No"
  )
) |>
  rowwise() |>
  mutate(
    Other = case_when(
      any(str_detect(c_across(Infection:Pain),"Yes")) ~ "No",
      .default = "Yes"
    ),
    PainIsol = case_when(
      any(str_detect(c_across(Infection:Effusion),"Yes")) | Other == "Yes" ~ "No",
      all(str_detect(c_across(Infection:Effusion),"No")) & Other == "No" & Pain == "Yes" ~ "Yes",
      .default = NA_character_
    )
  )
```

```{r}

ComplicFailCheck <- ComplicTable3 |> filter(
  !is.na(DateStatusChange)
) |> mutate(
  StatusDiff = ymd(DateStatusChange) - ymd(`Date of Occurrence`)
) |> relocate(
  StatusDiff,
  .after = DateStatusChange
) |> group_by(
  TreatmentID
) |> slice_max(
  `Date of Occurrence`
)

```

```{r}
#| label: Write-complications
#| eval: false


with_gs4_quiet(googlesheets4::range_write(
  ss = SheetIDs$AuditResults,
  data = ComplicTable3,
  sheet = "ComplicTable",
  range = "A1:AF",
  col_names = TRUE
)
)
```

Split out into arrays to bounce against for each Product report

```{r}

ComplicInfection <- ComplicTable3 |> dplyr::group_by(TreatmentID) |> filter(Infection == "Yes") |> slice_min(DateOccurFix, n = 1) |> ungroup()
ComplicLigament_Tendon <- ComplicTable3 |> group_by(TreatmentID) |> filter(Ligament_Tendon == "Yes") |> slice_min(DateOccurFix, n = 1) |> ungroup()
ComplicStiffness <- ComplicTable3 |> group_by(TreatmentID) |> filter(Stiffness == "Yes") |> slice_min(DateOccurFix, n = 1) |> ungroup()
ComplicLoosening <- ComplicTable3 |> group_by(TreatmentID) |> filter(Loosening == "Yes") |> slice_min(DateOccurFix, n = 1) |> ungroup()
ComplicHardware <- ComplicTable3 |> group_by(TreatmentID) |> filter(Hardware == "Yes" & Loosening == "No") |> slice_min(DateOccurFix, n = 1) |> ungroup()
ComplicInstability <- ComplicTable3 |> group_by(TreatmentID) |> filter(Instability == "Yes") |> slice_min(DateOccurFix, n = 1) |> ungroup()
ComplicNeurological <- ComplicTable3 |> group_by(TreatmentID) |> filter(Neurological == "Yes") |> slice_min(DateOccurFix, n = 1) |> ungroup()
ComplicFracture <- ComplicTable3 |> group_by(TreatmentID) |> filter(Fracture == "Yes") |> slice_min(DateOccurFix, n = 1) |> ungroup()
ComplicThrombosis <- ComplicTable3 |> group_by(TreatmentID) |> filter(Thrombosis == "Yes") |> slice_min(DateOccurFix, n = 1) |> ungroup()
ComplicEffusion <- ComplicTable3 |> group_by(TreatmentID) |> filter(Effusion == "Yes") |> slice_min(DateOccurFix, n = 1) |> ungroup()
ComplicPain <- ComplicTable3 |> group_by(TreatmentID) |> filter(PainIsol == "Yes") |> slice_min(DateOccurFix, n = 1) |> ungroup()
ComplicOther <- ComplicTable3 |> group_by(TreatmentID) |> filter(Other == "Yes") |> slice_min(DateOccurFix, n = 1) |> ungroup()
ComplicReop <- ComplicTable3 |> group_by(TreatmentID) |> filter(`Reoperation Procedure` == "Yes") |> slice_min(DateOccurFix, n = 1) |> ungroup()


```

<!--# Review intraoperative complications manually for mechanism -->

Intraoperative complications were reviewed manually for mechanism.

```{r}
#| label: Complication-discrepancies
#| eval: false

ComplicDiscrep <- ComplicTable3 |> filter(
  DateCheck == "Check"|
    is.na(`Complication Nature`)|
    (`Reoperation Procedure` == "Yes" & `Complication Occurrence` == "No")
)

#Identify duplicate entries
ComplicDiscrep2 <- ComplicTable3 |>
  group_by(TreatmentID, DateOccurFix) |>
  filter(n() > 1)

# Identify the problematic codes that are not linking back to the ProductTable correctly

with_gs4_quiet(googlesheets4::range_write(
  ss = SheetIDs$AuditResults,
  data = bind_rows(ComplicDiscrep,ComplicDiscrep2) |> arrange(TreatmentID),
  sheet = "ComplicDiscrepancy",
  range = "A1:AD",
  col_names = TRUE
)
)


```

```{r}
#| label: Complications-missing
#| eval: false

# Comment out after first use
 # range_write(ComplicTable4,
 #             ss = "https://docs.google.com/spreadsheets/d/1e7431oSrK9tItiSZb4wCWPI7nqGqawH8pNgnqgHPNkU/edit",
 #             sheet = "ComplicDiscrepancy2",
 #             range = "A1:AC")

 with_gs4_quiet(range_write(SnapshotComb2a |>
               filter(SurgicalTreatment == "Surgical" & is.na(ComplicationOccurrence)) |>
               dplyr::select(TreatmentID,DateTreatment),
             ss = SheetIDs$AuditResults,
             sheet = "ComplicMissing",
            range = "A1:C")
 )
```


# PRULO Summary

The diagram below summarises recruitment and categorisation of patients into the PRULO registry.

```{r}
#| label: strobe-input
#| code-summary: "CONSORT|STROBE"


# Inclusion
# - Surgical treatment
# - With hardware of interest
# After "induction"
# - Patient withdraws consent
# - Treatment fails before analysis date
# - Not eligible for 12m followup
# 

STROBEFlow <- STROBEInput |> dplyr::filter(
  !is.na(TreatmentID)
) |> dplyr::left_join(
  SnapshotComb1 |> dplyr::select(
    TreatmentID,
    CombID,
    DateInitialExamination,
    EligibleAtPreop,
    EligibleAtx3months,
    EligibleAtx12months
  ),
  by = "TreatmentID"
) |> dplyr::mutate(
  DurationTotal = as.numeric(as.duration(interval(ymd(DateTreatment), ymd(SnapshotDate))),"days"),
  exclusion1 = case_when(
    is.na(SurgicalTreatment) ~ "Not a surgical treatment",
    SurgicalTreatment == "Surgical" ~ NA_character_,
    .default = "Not a surgical treatment"
  ),
  exclusion2 = case_when(
    is.na(exclusion1) & stringr::str_detect(RegistryStatus,"Opt-out") ~ "Patient Opt-Out",
    is.na(exclusion1) & stringr::str_detect(ImplantCodes,"05.10.002") ~ NA_character_,
    #is.na(exclusion1) & Surgeon != "RP" ~ "Other Surgeon",
    is.na(exclusion1) & stringr::str_detect(ImplantCodes,"05.10.002", negate = TRUE) | is.na(ImplantCodes) ~ "No hardware of interest"
  ),
  followup = if_else(
    is.na(exclusion1) & is.na(exclusion2),
    TreatmentID,
    NA_character_
  ),
  lost_followup = case_when(
    is.na(exclusion1) & is.na(exclusion2) & TreatmentStatus == "Failed" & (ymd(DateStatusChange) < ymd(SnapshotDate)) ~ "Repair failure",
    is.na(exclusion1) & is.na(exclusion2) & TreatmentStatus == "No further followup" & (ymd(DateStatusChange) < ymd(SnapshotDate)) ~ "Patient Opt-out",
    is.na(exclusion1) & is.na(exclusion2) & TreatmentStatus == "Ongoing" & is.na(EligibleAtx3months) ~ "Not eligible for followup"
  ),
  mitt = if_else(
    !is.na(followup) & is.na(lost_followup),
    TreatmentID,
    NA_character_
)
) |> dplyr::rename(
  trialno = "TreatmentID",
  arm3 = "RegistryCohortName"
)


```

```{r}
#| label: fig-strobe
#| fig-cap: "Flowchart of data extraction and case selection up to 3 months followup across each cohort"

STROBEPlot <- consort::consort_plot(
  data = STROBEFlow,
  orders = c(
    trialno = "Population",
    exclusion1 = "Excluded",
    trialno = "Received Surgery",
    exclusion2 = "Excluded from Sample",
    followup = "Study Sample at Baseline",
    arm3 = "Diagnostic Group",
    lost_followup = "Unavailable 3m",
    mitt = "Final Analysis"),
side_box = c(
  "exclusion1", 
  "exclusion2",
  "lost_followup"
  ),
allocation = "arm3",
cex = 0.7
)

knitr::knit_print(STROBEPlot)
```

```{r}
#| label: tbl-diagnosis
#| tbl-cap: "Summary of diagnoses using ICD-10 coding for primary presentation"

DiagnosisData <- MasterTable1 |> dplyr::filter(
  TreatmentID %in% STROBEFlow$followup
) |> mutate(
    ICD10 = stringr::str_extract(DiagnosisPrimary,"^[A-Za-z]+[0-9.]+")
  )

TableData <- DiagnosisData |> group_by(
           Cohort
           ) |> count(
             ICD10, 
             sort = TRUE
             ) |> slice_head(n = 5) 

knitr::kable(TableData)


```

The table below summarises patient diagnoses in the PRULO registry. The primary pathology for a given presentation was derived from clinical notes and labelled with an ICD-10 (international) code. Each code was included in a configuration file to link to a registry cohort.

```{r}
#| label: tbl-surgical
#| tbl-cap: "Summary of PRULO surgical cases by cohort"

TableRepB <-
  SnapshotComb4 |> mutate(
    SurgeonA = case_when(
    Surgeon == "KE" ~ "A",
    Surgeon == "RP" ~ "B",
    Surgeon == "GB" ~ "C",
    .default = NA_character_
  )) |>
  filter(SurgicalTreatment == "Surgical" &
          !grepl("Pending",TreatmentStatus)) |>
  dplyr::select(
    AgeAtInitialExam, 
    Sex,
    Cohort,
    IndexSide,
    BilateralStatus,
    SymptomDuration,
    SymptomDurationCat,
    #SurgeonA,
    TreatmentStatus,
    RegistryStatus
    ) |>
    tbl_summary(
      by = "Cohort",
      label = list(
        #SurgeonA ~ "Surgeon",
        AgeAtInitialExam ~ "Age at Initial Consultation (Years)",
        Sex = "Male",
        BilateralStatus ~ "Bilateral Presentation",
        IndexSide ~ "Dominant Side",
        TreatmentStatus ~ "Treatment Record Active",
        RegistryStatus ~ "Patient Record Active",
        SymptomDuration ~ "Symptom Duration (Weeks)",
        SymptomDurationCat ~ "Symptom Duration Category"
      ),
      type = list(
        Sex ~ "dichotomous",
        TreatmentStatus ~ "dichotomous"
      ),
      value = list(
        Sex = "Male",
        IndexSide = "Dominant",
        TreatmentStatus = "Ongoing",
        RegistryStatus = "Open"
      ),
      statistic = list(
        all_categorical() ~ "{p} ({n})"
        ),
      missing = "no"
    ) |> add_stat_label(
    location = "column"
  ) |> add_overall() |> modify_table_styling(
      columns = label,
      rows = label == "Symptom Duration Category",
      footnote = "Dichotomised below or equal to 0.5 years or greater than 0.5 years"
  ) |> modify_table_styling(
      columns = label,
      rows = label == "Treatment Record Active",
      footnote = "Treatment record remains active - no change to follow up"
  ) |> modify_table_styling(
      columns = label,
      rows = label == "Patient Record Active",
      footnote = "Patient record remains open - no change to consent or mortality status"
  ) 

gtsummary::as_flex_table(TableRepB) |> flextable::set_table_properties(
  layout = "autofit",
  width = 0.15,
  align = "center",
  opts_word = list(
    split = TRUE
    )
  )

```

<!--# Removed SymptomDurationCat - turning it into a factor was problematic when constructing the summary table with gtsummary-->

The overall registry enrolment is summarised in @tbl-surgical, describing how the population is summarised into cohorts.

# Product Report 1 - Healix Advance PEEK with Dynacord

## Sample Selection

The sample of patients with the relevant product group were identified and data were retrieved for analysis by matching registry records to the relevant stock keeping units (SKUs) for the product group of interest. Usage statistics for the product group were added, and adverse events data were attached. Patient-reported data were retrieved and the dataset was manipulated to include relevant details for procedures of interest.

```{r}
#| label: Reference-Code-Rep1

RefCode1 <- ProductTable |> filter(
  Category == "Anchor + Suture" &
  stringr::str_detect(stringr::str_to_lower(Description),"advance") &
  stringr::str_detect(stringr::str_to_lower(Description),"peek") &
  stringr::str_detect(stringr::str_to_lower(Description),"dynacord") &
  stringr::str_detect(stringr::str_to_lower(Description),"healix")  
)

```

```{r}
#| label:  Slice-stack-Rep1


Pattern1 <- "(healix advance peek dynacord)"

SelectRep1 <- SnapshotComb4 |> 
  filter(
    str_detect(ImplantCodes,paste(RefCode1$Reference,collapse = "|"))
  ) |> mutate(
    Product1Check = stringr::str_detect(stringr::str_to_lower(Product1),Pattern1),
    Product2Check = stringr::str_detect(stringr::str_to_lower(Product2),Pattern1),
    Product3Check = stringr::str_detect(stringr::str_to_lower(Product3),Pattern1),
    Product4Check = stringr::str_detect(stringr::str_to_lower(Product4),Pattern1)
  ) |> mutate(
    Product1Count = case_when(
      Product1Check == TRUE ~ stringr::str_extract(Product1,"\\d"),
      .default = NA
    ),
    Product2Count = case_when(
      Product2Check == TRUE ~ stringr::str_extract(Product2,"\\d"),
      .default = NA
    ),
    Product3Count = case_when(
      Product3Check == TRUE ~ stringr::str_extract(Product3,"\\d"),
      .default = NA
    ),
    Product4Count = case_when(
      Product4Check == TRUE ~ stringr::str_extract(Product4,"\\d"),
      .default = NA
      )
    ) |> mutate(
      across(Product1Count:Product4Count,~as.numeric(.))
    ) |> rowwise() |> mutate(
    ProductCount =  sum(across(Product1Count:Product4Count), na.rm = TRUE)
      ) |> mutate(
        ProductCountFct = forcats::fct(
            as.character(ProductCount),
            levels = c("1","2","3","4","5")
          )
        ) |> mutate(
  Infection = TreatmentID %in% ComplicInfection$TreatmentID,
  Ligament_Tendon = TreatmentID %in% ComplicLigament_Tendon$TreatmentID,
  Stiffness = TreatmentID %in% ComplicStiffness$TreatmentID,
  Loosening = TreatmentID %in% ComplicLoosening$TreatmentID,
  Hardware = TreatmentID %in% ComplicHardware$TreatmentID,
  Instability = TreatmentID %in% ComplicInstability$TreatmentID,
  Neurological = TreatmentID %in% ComplicNeurological$TreatmentID,
  Fracture = TreatmentID %in% ComplicFracture$TreatmentID,
  Thrombosis = TreatmentID %in% ComplicThrombosis$TreatmentID,
  Effusion = TreatmentID %in% ComplicEffusion$TreatmentID,
  Pain = TreatmentID %in% ComplicPain$TreatmentID,
  Other = TreatmentID %in% ComplicOther$TreatmentID,

  Reop = TreatmentID %in% ComplicReop$TreatmentID
) |> left_join(
  ComplicTable3 |> 
    group_by(TreatmentID) |>
    slice_max(
      ymd(`Reoperation Procedure Date`), 
      n = 1, 
      na_rm = TRUE,
      with_ties = FALSE
      ) |> ungroup() |> dplyr::select(
    TreatmentID,
    ReopDelay_Occur,
    ReopDelay_Surgery,
    EventDelay
  ),
  by = "TreatmentID"
)
```

```{r}
# validate slicemax

SliceCheck <- ComplicTable3 |> 
    group_by(TreatmentID) |>
    slice_max(
      ymd(`Reoperation Procedure Date`), 
      n = 1, 
      na_rm = TRUE,
      with_ties = FALSE
      ) |> dplyr::select(
    TreatmentID,
    `Complication ID`,
    ReopDelay_Occur,
    ReopDelay_Surgery,
    EventDelay,
    Timestamp
  ) |> ungroup() 
```

```{r}
#| label: Select-PROMs-Rep1

SelectRep1PROM1 <- SnapshotPROM1 |>
  filter(
    str_detect(ImplantCodes,paste(RefCode1$Reference,collapse = "|"))
  )

SelectRep1PROM2 <- SnapshotPROM2 |>
  filter(
    str_detect(ImplantCodes,paste(RefCode1$Reference,collapse = "|"))
  )

```

```{r}
#| label: Select-Procedure-Rep1

SelectRep1RC <- SelectRep1 |> filter(str_detect(CuffRepair,"Repair"))
#SelectRep1RCno <- SelectRep1 |> filter(str_detect(CuffRepair,"Repair",negate = TRUE) | is.na(CuffRepair))

SelectRep1RCPROM1 <- SelectRep1PROM1 |> filter(str_detect(CuffRepair,"Repair"))
SelectRep1RCPROM2 <- SelectRep1PROM2 |> filter(str_detect(CuffRepair,"Repair"))

SelectRep1BT <- SelectRep1 |> filter(str_detect(LongHeadBiceps,"Tenodesis"))
SelectRep1BTPROM1<- SelectRep1PROM1 |> filter(str_detect(LongHeadBiceps,"Tenodesis"))
SelectRep1BTPROM2<- SelectRep1PROM2 |> filter(str_detect(LongHeadBiceps,"Tenodesis"))
```

## Overview

Usage of the Product within the patient group is summarised below.

<!--# Insert date range into epoxy block -->

```{epoxy}
#| label:  Overview-Rep1

{
  if(nrow(SelectRep1) == 1) {
    epoxy::epoxy("There is {nrow(SelectRep1)} case involving the anchor of interest.")
  } else {
    procedures <- unique(SelectRep1$ProcedureTotal)
    procedures <- procedures[procedures != "None" & procedures != "Unknown" & procedures != ""]
    procedures <- procedures[!grepl("^(Tenodesis|Tenotomy)$", procedures)]
    
    procedures_string <- if(length(procedures) > 1) {
  result1 <- paste(procedures[-length(procedures)], collapse = "] [")
  paste0(result1, "], and [", procedures[length(procedures)])
    } else {
      procedures
    }
    
    epoxy::epoxy("There are {nrow(SelectRep1)} cases involving the anchor of interest. Surgeries were performed between {format(min(SelectRep1$DateTreatment),'%Y-%b-%d')} and {format(max(SelectRep1$DateTreatment),'%Y-%b-%d')}. The procedures included [{procedures_string}].")
  }
}
{ifelse(nrow(SelectRep1RC) == 1,
        epoxy::epoxy("There is {nrow(SelectRep1RC)} case involving the anchor of interest and a rotator cuff repair."),
        epoxy::epoxy("There are {nrow(SelectRep1RC)} cases involving the anchor of interest and a rotator cuff repair. Surgeries were performed between {format(min(SelectRep1RC$DateTreatment),'%Y-%b-%d')} to {format(max(SelectRep1RC$DateTreatment),'%Y-%b-%d')}.")
)} 
{ifelse(nrow(SelectRep1BT) == 1,
        epoxy::epoxy("There is {nrow(SelectRep1BT)} case involving the anchor of interest and a biceps tenodesis."),
        epoxy::epoxy("There are {nrow(SelectRep1BT)} cases involving the anchor of interest and a biceps tenodesis. Surgeries were performed between {format(min(SelectRep1BT$DateTreatment),'%Y-%b-%d')} to {format(max(SelectRep1BT$DateTreatment),'%Y-%b-%d')}.")
)}




```

## Procedure Report - Rotator Cuff Repair

### Patient Characteristics

Patient demographic, pathology, and treatment characteristics for this cohort receiving the Product are summarised below.

```{r}
#| label: tbl-rep1RC1pat
#| tbl-cap: "Summary of PRULO Report 1 (Rotator Cuff) Case - Patient Characteristics"

#Dont insert chunk names into table chunks - quarto bug makes it wig out when there is a named chunk for some reason

TableRep1RC1 <- SelectRep1RC |> mutate(
    SurgeonA = case_when(
      Surgeon == "KE" ~ "A",
      Surgeon == "RP" ~ "B",
      Surgeon == "GB" ~ "C",
      .default = NA_character_
  )) |>
  dplyr::select(
    AgeAtInitialExam,
    Sex,
    Cohort,
    IndexSide,
    BilateralStatus,
    SymptomDuration,
    SymptomDurationCat,
    #SurgeonA,
    LongHeadBiceps,
    TreatmentStatus,
    RegistryStatus
    ) |>
    tbl_summary(
      by = LongHeadBiceps,
      label = list(
        #SurgeonA ~ "Surgeon",
        AgeAtInitialExam ~ "Age at Initial Consultation (Years)",
        Sex = "Male",
        BilateralStatus ~ "Bilateral Presentation",
        IndexSide ~ "Dominant Side",
        SymptomDuration ~ "Symptom Duration (Weeks)",
        SymptomDurationCat ~ "Symptom Duration Category",
        TreatmentStatus ~ "Treatment Record Active",
        RegistryStatus ~ "Patient Record Active"
      ),
      type = list(
        AgeAtInitialExam ~ "continuous",
        SymptomDuration ~ "continuous",
        Sex ~ "dichotomous",
        TreatmentStatus ~ "dichotomous",
        RegistryStatus ~ "dichotomous"
      ),
      value = list(
        Sex = "Male",
        IndexSide = "Dominant",
        TreatmentStatus = "Ongoing",
        RegistryStatus = "Open"
      ),
      statistic = list(
        all_categorical() ~ "{p} ({n})"
        ),
      missing = "no"
    ) |> add_stat_label(
    location = "column"
  ) |> add_overall() |> modify_table_styling(
      columns = label,
      rows = label == "Symptom Duration Category",
      footnote = "Dichotomised below or equal to 0.5 years or greater than 0.5 years"
  ) |> modify_table_styling(
      columns = label,
      rows = label == "Treatment Record Active",
      footnote = "Treatment record remains active - no change to follow up"
  ) |> modify_table_styling(
      columns = label,
      rows = label == "Patient Record Active",
      footnote = "Patient record remains open - no change to consent or mortality status"
  )

gtsummary::as_flex_table(TableRep1RC1) |> flextable::set_table_properties(
  layout = "autofit",
  width = 0.5,
  align = "center",
  opts_word = list(
    split = TRUE
    )
)

```

### Surgical Details

Surgical findings and management strategies are summarised below.

```{r}
#| eval: false

CuffStatus1 <- SelectRep1RC |> filter(is.na(CuffStatus))
```

<!--# There are a couple of cases that do not seem to fit the cuff status field properly. There is one GHI case that has the repair details (1399.1), but not cuff status inserted. The other is a general case that is a retorn RCR that probably needs to be moved across cohorts (193.2). -->

```{r}
#| label: tbl-rep1RC1Surg
#| tbl-cap: "Summary of PRULO Report 1 (Rotator Cuff) Cases Pathology and Surgical Details"

TableRep1RC2 <-
  SelectRep1RC |>
  dplyr::select(
    CuffStatus,
    TreatmentType,
    ProductCountFct, #This has a code block it depends on to derive this count within the dataframe - ensure its copied|amended into each report as required
    CuffRepair:AdjunctProcedure) |>
  tbl_summary(
      by = LongHeadBiceps,
      label = list(
        ProductCountFct ~ "Product Count",
        CuffStatus ~ "Cuff Status",
        TreatmentType ~ "Treatment Type",
        CuffRepair ~ "Cuff Repair",
        RepairAugmentation ~ "Repair Augmentation",
        LabrumRepair ~ "Labrum Repair",
        CapsuleLigament ~ "Capsule | Ligament",
        AdjunctProcedure ~ "Adjunct Procedure"
      ),
      statistic = list(
        all_categorical() ~ "{p} ({n})"
        ),
      missing = "no"
    ) |> add_overall() |> modify_table_styling(
      columns = label,
      rows = label == "Other",
      footnote = "Biceps tendon integration; Biceps tendon transfer; Tendon advancement"
    ) 

gtsummary::as_flex_table(TableRep1RC2) |> flextable::set_table_properties(
  layout = "autofit",
  width = 0.15,
  align = "center",
  opts_word = list(
    split = TRUE
    )
)

  
```

### Treatment Survival

```{epoxy}
#| label:  Duration-Rep1-Proc1

The mean follow up duration is {round(SelectRep1RC |> ungroup() |> summarise(mean = mean(Duration))/52,1)} years, with a standard deviation of {round(SelectRep1RC |> ungroup() |> summarise(sd = sd(Duration))/52,2)} years.

```

Failure or revision events as identified in the registry for this cohort are summarised below. Individual failure data can be accessed in [Attachment 1](https://docs.google.com/spreadsheets/d/1ESVvSKAv8ma11kri9pby6OEU9Gk5Z3UnF6XwjXBTcTg/edit#gid=0).

```{r}
#| label: tbl-rep1RC3
#| tbl-cap: "Summary of PRULO Report 1 (Rotator Cuff) Procedure Survival"

TableRep1RC3 <- tbl_survfit(
  survfit2(Surv(Duration, Status) ~ 1, 
           data = SelectRep1RC),
  times = c(1,26,52,104),
  label_header = "**{time} Weeks**",
  label = "Procedure Survival",
  statistic = "{estimate} ({conf.low} - {conf.high})"
) |> gtsummary::modify_footnote_header(
    footnote = "% survival with 95% confidence intervals",
    columns = all_stat_cols(),
  ) |> gtsummary::modify_footnote_header(
    footnote = "% survival with 95% confidence intervals",
    columns = all_stat_cols(),
  )

gtsummary::as_flex_table(TableRep1RC3) |> flextable::set_table_properties(
  layout = "autofit",
  width = 0.5,
  align = "left",
  opts_word = list(
    split = TRUE
    )
)

```

```{r}
#| label:  Failure-Rep-Rep1A-Proc1

#Previous surgery(ies) at the same site Anatomical Location 
#Anchor 1 Anchor 2 Anchor 3 Anchor 4

FailuresRep1RC <-
  SelectRep1RC |> mutate(
    TreatmentStatusDesc = stringr::str_to_sentence(TreatmentStatusNotes)
  ) |>
      filter(TreatmentStatus == "Failed") |> 
  dplyr::select(
    TreatmentID,
    AgeAtInitialExam, 
    Sex,
    TreatmentType,
    Duration,
    TreatmentStatusDesc,
    ReoperationProcedure2,
    SubsequentTx2,
    Product1,
    Product2,
    Product3,
    Product4,
    QDASH_TotalScore_Preop,
    QDASH_TotalScore_3months,
    QDASH_TotalScore_6months) |> mutate(
      Group = "CuffRepair"
    )

```

```{r}
#| label:  Failure-Report-Rep1B-Proc1
#| eval: true

{ifelse(nrow(FailuresRep1RC) == 0,
        epoxy::epoxy("There are no failures or revisions to report."),
       with_gs4_quiet(googlesheets4::range_write(
         ss = SheetIDs$AuditReport,
         data = FailuresRep1RC |> arrange(TreatmentID),
         sheet = "Failures1",
         range = "A1:P",
         col_names = TRUE
         )
       )
)}


```

### Adverse Events

Complications and adverse events are summarised below. Individual reoperation data can be accessed in [Attachment 1](https://docs.google.com/spreadsheets/d/1ESVvSKAv8ma11kri9pby6OEU9Gk5Z3UnF6XwjXBTcTg/edit#gid=0).

```{r}
#| label:  Complication-Other-Rep1

SelectRep1Other <- SelectRep1 |> filter(
  Other == TRUE
) |> dplyr::select(
  TreatmentID,
  DateTreatment,
  Cohort
)
```



```{r}
#| label: tbl-intraop-complications-1A
#| tbl-cap: "Summary of PRULO Report 1 (Rotator Cuff) Cases - Intraoperative Events"

# Check if any complications exist in filtered data
has_complications <- SelectRep1RC |> 
  filter(TreatmentID %in% IntraopComp$TreatmentID) |> 
  nrow() > 0

# Conditionally generate content
if (!has_complications) {
  # If no complications, return the text message
  epoxy("No intraoperative complications observed.")
} else {
  # Calculate incidence and confidence intervals
  total_cases <- nrow(SelectRep1RC)
  complication_cases <- SelectRep1RC |> 
    filter(TreatmentID %in% IntraopComp$TreatmentID) |> 
    nrow()
  
  # Calculate proportion and 95% CI using Wilson method
  prop_result <- binom::binom.confint(complication_cases, total_cases, 
                                      methods = "wilson")
  incidence_pct <- round(prop_result$mean * 100, 1)
  ci_lower <- round(prop_result$lower * 100, 1)
  ci_upper <- round(prop_result$upper * 100, 1)
  
  # Generate summary sentence
  summary_text <- glue::glue(
    "Intraoperative events occurred in {complication_cases} of {total_cases} cases ({incidence_pct}%, 95% CI: {ci_lower}%-{ci_upper}%)."
  )
  
  # Print summary sentence
  cat(summary_text, "\n\n")
  
  # Generate and return the table
  IntraopComp |> 
    filter(TreatmentID %in% SelectRep1RC$TreatmentID) |> 
    rename(
      Description = "ICNature2",
      Intervention = "ICIntervention",
      PostopManagement = "ICPostopManagement"
    ) |> 
    select(
      TreatmentID,
      Description,
      Intervention,
      PostopManagement
    ) |> 
    gt::gt()
}

```




```{r}
#| label: tbl-Rep1RC4
#| tbl-cap: "Summary of PRULO Report 1 (Rotator Cuff) Cases - Postoperative Events."

# Now create the summary table
TableRep1RC4 <- SelectRep1RC |>
  dplyr::select(
    Infection,
    Ligament_Tendon,
    Effusion,
    Pain,
    Hardware,
    Loosening,
    Instability,
    Stiffness,
    Neurological,
    Thrombosis,
    Other,
    Reop,
    SubsequentTx2, #Inserted to address C028
    ReopDelay_Surgery) |>
  tbl_summary(
    label = list(
      Ligament_Tendon ~ "Ligament|Tendon (Retear)",
      ReopDelay_Surgery ~ "Reoperation Delay (Weeks)",
      
      Reop ~ "Reoperation",
      SubsequentTx2 ~ "Subsequent Treatment"
      ),
    type = list(
      ReopDelay_Surgery ~ "continuous"
    ),
    statistic = list(
      all_categorical() ~ "{p} ({n})",
      all_continuous() ~ "{mean} ({sd})"
    ),
    missing = "no",) |> add_ci(
      statistic = list(
        all_categorical() ~ "{conf.low} - {conf.high}",
        all_continuous() ~ "{conf.low} - {conf.high}"
        
      )
    ) |> modify_table_styling(
      columns = label,
      rows = label == "Other",
      footnote = "Myocardial Infarction"
    ) |> modify_table_styling (
      columns = label,
      rows = label == "Subsequent Treatment",
      footnote = "Management undertaken for procedures that have suffered tissue failure or required hardware removal or replacement"
    ) |> modify_table_styling(
      columns = label,
      rows = label == "Reoperation",
      footnote = "A theatre procedure subsequent to the index surgery that does not involve removal, replacement or modification of the construct."
    ) |> modify_table_styling(
      columns = label,
      rows = label == "Reoperation Delay (Weeks)",
      footnote = "Time between index procedure and reoperation"
    ) 

gtsummary::as_flex_table(TableRep1RC4) |> flextable::set_table_properties(
  layout = "autofit",
  width = 0.5,
  align = "center",
  opts_word = list(
  split = TRUE
  )
)

```

```{r}
#| label:  Reoperations-Rep1A-Proc1

#echo: false
#warning: false

#Previous surgery(ies) at the same site Anatomical Location 
#Anchor 1 Anchor 2 Anchor 3 Anchor 4

##Flip this around so that multiple reoperations are retained


SelectRep1RCReop <- ComplicTable3 |> filter(
  TreatmentID %in% SelectRep1RC$TreatmentID,
  `Reoperation Procedure` == "Yes"
  ) |> group_by(TreatmentID) |> slice_min(
    ReopDelay_Surgery,
    n = 1
    ) |> ungroup() |> left_join(
    SelectRep1 |> dplyr::select(
    TreatmentID,
    AgeAtInitialExam,
    Sex,
    TreatmentType,
    Product1,
    Product2,
    Product3,
    Product4,
    QDASH_TotalScore_Preop,
    QDASH_TotalScore_3months,
    QDASH_TotalScore_6months
      ),
    by = "TreatmentID",
    relationship = "one-to-one"
    ) |>
  mutate(
     QDASH_TotalScore_Preop = as.numeric(QDASH_TotalScore_Preop),
     QDASH_TotalScore_3months = as.numeric(QDASH_TotalScore_3months),
     QDASH_TotalScore_6months =as.numeric(QDASH_TotalScore_6months)
  ) |> dplyr::select(
    TreatmentID,
    AgeAtInitialExam,
    Sex,
    TreatmentType,
    `Complication Nature`,

    EventDelay,
    Product1,
    Product2,
    Product3,
    Product4,
    QDASH_TotalScore_Preop,
    QDASH_TotalScore_3months,
    QDASH_TotalScore_6months
    ) |> mutate(
      Procedure = "Cuff Repair"
      ) |> arrange(
    TreatmentID
    )

```

<!--# Write reoperations to external sheet -->

```{epoxy}
#| label: Reoperations-Report-Rep1B-Proc1
#| eval: true

{ifelse(nrow(SelectRep1RCReop) == 0,
        epoxy::epoxy("There are no reoperations or to report."),
       with_gs4_quiet(googlesheets4::range_write(
         ss = SheetIDs$AuditReport,
         data = SelectRep1RCReop,
         sheet = "Reoperations1",
         range = "A1:P",
         col_names = TRUE
         )
      )
)
      }



```

### Patient-Reported Outcomes

Complete case analysis of QDASH, WORC Index Normalised, and WORC Physical Question 3 (How much weakness do you experience in your shoulder?) is summarised below.

```{r}
#| label: fig-PROMs-Rep1
#| fig-cap: "Complete case analysis of QDASH(Top), WORC Normalised (Middle) and WORC Physical Question 3 (Bottom)."
#| fig-cap-location: bottom

Rep1RCPROM1 <- ggplot(data = SelectRep1RCPROM1, mapping = aes(Timepoint,QDASH)) + 
geom_boxplot()

Rep1RCPROM2 <- ggplot(data = SelectRep1RCPROM2, mapping = aes(Timepoint,WORCNorm)) + 
geom_boxplot()

Rep1RCPROM3 <- ggplot(data = SelectRep1RCPROM2, mapping = aes(Timepoint,WORCPhysicalQ3)) + 
geom_boxplot()

Rep1RCPROM1 / Rep1RCPROM2 / Rep1RCPROM3

```

```{r}
#| label: tbl-PROMs-Rep1
#| tbl-cap: "Summary of PRULO Report 1 (Rotator Cuff) Cases - QuickDASH"


TableRep1RC5 <- SelectRep1RCPROM1 |>
dplyr::select(
  QDASH,
  QDASHDelta,
  Timepoint) |>
tbl_summary(by = "Timepoint",
            missing = "no",
            type = list(
              QDASH ~ "continuous",
              QDASHDelta ~ "continuous"
            ),
            statistic = all_continuous() ~ "{median} ({p25} - {p75})"
            ) 


gtsummary::as_flex_table(TableRep1RC5) |> flextable::set_table_properties(
  layout = "autofit",
  width = 0.5,
  align = "center",
  opts_word = list(
  split = TRUE
  )
)



```

```{r}
#| label: tbl-PROMs-Rep1Worc
#| tbl-cap: "Summary of PRULO Report 1 (Rotator Cuff) Cases - Western Ontario Rotator Cuff Index"


TableRep1RC6 <- SelectRep1RCPROM2 |>
dplyr::select(WORCNorm,
              WORCPhysicalQ3,
              WORCDelta,
              Timepoint) |>
tbl_summary(by = "Timepoint",
            missing = "no",
            type = list(
              WORCNorm ~ "continuous",
              WORCPhysicalQ3 ~ "continuous",
              WORCDelta ~ "continuous"
            ),
            statistic = all_continuous() ~ "{median} ({p25} - {p75})")  

gtsummary::as_flex_table(TableRep1RC6) |> flextable::set_table_properties(
  layout = "autofit",
  width = 0.5,
  align = "center",
  opts_word = list(
  split = TRUE
  )
)

```
