---
title: "PRULO_MedactaReport"
author: "Corey Scholes"
type: "website"
number-sections: true
number-depth: 3
date: "2025-Apr-11"
date-modified: "2025-Jul-23"
bibliography: MedactaReport references.bib
format: 
  html:
    df-print: paged
    toc: true
    toc-depth: 1
    toc-expand: true
    toc-location: right-body
    link-external-icon: true
    link-external-newwindow: true
    smooth-scroll: true
    fig_caption: yes
  pdf:
    toc: true
    colorlinks: true
    fig_caption: yes
  docx: 
    toc: true
    fig-align: center
    fig_caption: yes
editor: visual
execute:
  echo: false
  warning: false
  message: false
---

# Preamble

**Author:** Corey Scholes, EBM Analytics

**Sponsors:** Assoc Prof Kevin Eng and Prof Richard Page, Geelong Orthopaedics

**EBMAReference**: RC_MedactaReporting_KE010Sep25

**Version:** 1.0

# Introduction

The surgeons from Geelong Orthopaedics participating in the Patient Registry of Upper Limb Pathology Outcomes (PRULO) specialise in joint replacement, sports injuries, upper limb and hand surgery, and trauma. The PRULO registry collates and stores patient outcomes collected routinely as part of the standard clinical pathway for upper limb pathology treatment.

The registry comprises three patient cohorts: rotator cuff pathology, glenohumeral instability, and general shoulder pathologies. Outcomes data collected by the registry include objective joint function, patient reported outcomes (pain, satisfaction, quality of life), radiological findings, surgical treatment and rates of revision surgery or complications.

The dataset is derived from the PRULO registry snapshot and live database tables. A [protocol](https://academic.oup.com/jsprm/article/2023/4/snad014/7317733) has been previously prepared for the registry @scholes2023.

# Glossary

To clarify terms used throughout the report, a glossary is presented below.

::: {#tbl-glossary}
+--------------------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| Term                     | Definition                                                                                                                                                                                                                                                                           |
+==========================+======================================================================================================================================================================================================================================================================================+
| Case Failure             | Patient presents in a state such that                                                                                                                                                                                                                                                |
|                          |                                                                                                                                                                                                                                                                                      |
|                          | i\) a repaired construct is deemed to be absent healing, or has reinjured subsequent to the index procedure                                                                                                                                                                          |
|                          |                                                                                                                                                                                                                                                                                      |
|                          | ii\) the shoulder presents in a state such that removal of hardware or procedure revision (single or multi-stage) is recommended                                                                                                                                                     |
+--------------------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| Reoperation              | A theatre procedure subsequent to the index surgery that does not involve removal, replacement or modification of the construct.                                                                                                                                                     |
+--------------------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| Case                     | A definitive reconstruction procedure performed on a patient, excluding a reoperation, but including revision procedures.                                                                                                                                                            |
+--------------------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| Revision Else            | A repeat definitive procedure performed on a case where the previous definitive procedure has been performed by another surgeon                                                                                                                                                      |
+--------------------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| Revision Own             | A repeat definitive procedure performed on a case where the previous definitive procedure has been performed by the same contributing surgeon                                                                                                                                        |
+--------------------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| QuickDASH                | Short form of the Disabilities of the Arm, Hand and Shoulder questionnaire. The questions are directed toward pain and disability associated with upper limb activities. A diminishing score over time reflects improved function.                                                   |
+--------------------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| WORCNorm                 | Western Ontario Rotator Cuff Index is a questionnaire specific to rotator cuff pathology and is scored as the sum of a series of 10mm visual analogue scales. A normalised score is calculated to convert the sum to a percentage score of normal (100%).                            |
+--------------------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| WORC Physical Question 3 | Question 3 of the Physical subscale of the WORC asks "How much weakness do you experience in your shoulder?" and is a                                                                                                                                                                |
+--------------------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| WOSINorm                 | Western Ontario Rotator Cuff Index is a questionnaire specific to glenohumeral instability and associated pathology and is scored as the sum of a series of 10mm visual analogue scales. A normalised score is calculated to convert the sum to a percentage score of normal (100%). |
+--------------------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+

Glossary of terms used in report
:::

# Data Preparation

The steps below outline the process for preparing registry data for analysis.

## Load libraries

Load up required packages in advance.

```{r}
#| label: Load packages

 if(!require("pacman")) install.packages("pacman")
pacman::p_load(
  "knitr",
  "cardx",
  "quarto",
  "memoise",
  "gargle",
  "googledrive",
  "googlesheets4",
  "readr",
  "tidyverse",
  "tidytext",
  "stopwords",
  "lubridate",
  "forcats",
  "gt",
  "consort",
  "gtsummary",
  "flextable",
  "survival",
  "ggplot2",
  "ggdist",
  "ggsurvfit",
  "ggfortify",
  "mice",
  "marginaleffects",
  "patchwork",
  "naniar",
  "broom",
  "broom.helpers",
  "labelled",
  "epoxy",
  "janitor",
  "DT",
  install = TRUE,
  update = FALSE
)

```

## Authorisations

Pre-authorise access to registry datasets.

```{r}
#| label: Authorisations
#| echo: false

options(
  gargle_oauth_cache = ".secrets",
  gargle_oauth_email = TRUE
)

drive_auth(cache = ".secrets", email = TRUE)

```

## Functions for Processing

Include a series of functions to call later in the file for processing data imports.

```{r}
#| label: Snapshot-folder
#| echo: false

base_folder_id1 <- "1og1hWKEXFcy8v8pLSzA_Ii767bbCe_EK"


```

```{r}
#| label: Retrieve-snapshot


get_latest_snapshot <- function(base_folder_id = base_folder_id1) {
  tryCatch({
    # List all folders in the base directory
    folders <- googledrive::drive_ls(as_id(base_folder_id), pattern = "^\\d{8}$")
    
    if(nrow(folders) == 0) {
      stop("No dated folders found")
    }
    
    # Sort folders by name (date) in descending order
    latest_folder <- folders[order(folders$name, decreasing = TRUE),][1,]
    
    # Find the snapshot file in the latest folder
    snapshot_file <- googledrive::drive_ls(
      latest_folder$id, 
      pattern = "Registry data snapshot\\.xlsx$"
    )
    
    if(nrow(snapshot_file) == 0) {
      stop("No snapshot file found in latest folder")
    }
    
    # Return both pieces of information as a list
    return(list(
      snapshot = snapshot_file,
      folder_name = latest_folder$name
    ))
    
  }, error = function(e) {
    stop(paste("Error finding latest snapshot:", e$message))
  })
}
```

```{r}
# Function to generate multiple dataframe pairs from a configuration list
Generate_selectrep <- function(config_list, ProductTable, SnapshotComb4, 
                               ComplicInfection, ComplicLigament_Tendon, 
                               ComplicStiffness, ComplicLoosening, ComplicHardware, 
                               ComplicInstability, ComplicNeurological, ComplicFracture,
                               ComplicThrombosis, ComplicEffusion, ComplicPain, 
                               ComplicOther, ComplicIntraop, ComplicReop, ComplicTable3, 
                               ...) {
  
  result_list <- list()
  
  for(i in seq_along(config_list)) {
    config <- config_list[[i]]
    df_name <- names(config_list)[i]
    
    # Prepare PROM arguments if specified
    prom_args <- list()
    if (!is.null(config$proms)) {
      dots <- list(...)
      for (prom_name in config$proms) {
        if (prom_name %in% names(dots)) {
          prom_args[[prom_name]] <- dots[[prom_name]]
        }
      }
    }
    
    # Create the dataframe pair with subsets and PROMs
    df_results <- do.call(create_dataframe_pair, c(
      list(
        df_name = df_name,
        category = config$category,
        search_terms = config$search_terms,
        pattern = config$pattern,
        subsets = config$subsets,
        proms = config$proms,
        ProductTable = ProductTable,
        SnapshotComb4 = SnapshotComb4,
        ComplicInfection = ComplicInfection,
        ComplicLigament_Tendon = ComplicLigament_Tendon,
        ComplicStiffness = ComplicStiffness,
        ComplicLoosening = ComplicLoosening,
        ComplicHardware = ComplicHardware,
        ComplicInstability = ComplicInstability,
        ComplicNeurological = ComplicNeurological,
        ComplicFracture = ComplicFracture,
        ComplicThrombosis = ComplicThrombosis,
        ComplicEffusion = ComplicEffusion,
        ComplicPain = ComplicPain,
        ComplicOther = ComplicOther,
        ComplicIntraop = ComplicIntraop,
        ComplicReop = ComplicReop,
        ComplicTable3 = ComplicTable3
      ),
      prom_args
    ))
    
    # Store main dataframes
    result_list[[paste0("RefCode", i)]] <- df_results$RefCode
    result_list[[paste0("SelectRep", i)]] <- df_results$SelectRep
    
    # Store PROMs
    if (!is.null(config$proms)) {
      for (prom_name in config$proms) {
        if (prom_name %in% names(df_results)) {
          result_list[[paste0("SelectRep", i, prom_name)]] <- df_results[[prom_name]]
        }
      }
    }
    
    # Store subsets with appropriate naming
    if (!is.null(config$subsets)) {
      for (subset_name in names(config$subsets)) {
        # Main subset
        if (subset_name %in% names(df_results)) {
          result_list[[paste0("SelectRep", i, subset_name)]] <- df_results[[subset_name]]
        }
        
        # PROM subsets
        if (!is.null(config$proms)) {
          for (prom_name in config$proms) {
            prom_subset_name <- paste0(subset_name, prom_name)
            if (prom_subset_name %in% names(df_results)) {
              result_list[[paste0("SelectRep", i, prom_subset_name)]] <- df_results[[prom_subset_name]]
            }
          }
        }
      }
    }
  }
  
  return(result_list)
}
```

## Import Inputs

Data was imported from the PRULO registry. Configuration tables were also loaded, including the product table to describe the products of interest and list identifiers to match to surgical records. The table was modified to include a material column (PEEK or BR) and product identifiers.

```{r}
#| label: Specify-sources
#| echo: false

SheetIDs <- list(
  DbPRULO = "https://docs.google.com/spreadsheets/d/1zyFuf0Wmij13ELTYNmdi_BprF8hU4QSCPsNZ0EYRXzo/edit",
  ProductTable = "https://docs.google.com/spreadsheets/d/1MvT00sc8FzH5SXEi-yzEgW1H1ao3AOoakKqpg7UkxW4/edit",
  RefIgnore =   "https://docs.google.com/spreadsheets/d/1MvT00sc8FzH5SXEi-yzEgW1H1ao3AOoakKqpg7UkxW4/edit",
  PROMsMaster = "https://docs.google.com/spreadsheets/d/1zyFuf0Wmij13ELTYNmdi_BprF8hU4QSCPsNZ0EYRXzo/edit",
  TargetTerms = "https://docs.google.com/spreadsheets/d/1ESVvSKAv8ma11kri9pby6OEU9Gk5Z3UnF6XwjXBTcTg/edit",
  AuditResults = "https://docs.google.com/spreadsheets/d/1GyHw8hyyOcqkSzxlQL_hlxyvFR_a1jS3LzYc2B_y_fA/edit",
  AuditReport = "https://docs.google.com/spreadsheets/d/1Qxi8d45TDNet2d5-FYliyzgXsSW8Dx73A0oe4GPg0RI/edit"
  
)

```

```{r}
#| label: Read-live-tables

# Authenticate for sheets using the same token
gs4_auth(token = drive_token())

ComplicTable <- googlesheets4::read_sheet(
  ss = SheetIDs$DbPRULO,
  sheet = "Complications",
  range = "A1:H",
  col_names = TRUE,
  col_types = "TcccDccD"
  )

PatientTable <- googlesheets4::range_read(
  ss = SheetIDs$DbPRULO,
  sheet = "Patient",
  col_names = c(
  "PatientCreationDate",
  "PatientID",
  "LastName",
  "FirstName",
  "AlternateID",
  "DateOfBirth",
  "Sex",
  "RegistryStatus",
  "RegistryStatusNotes",
  "DateRegistryStatus",
  "NotificationMethod",
  "NoTreatmentRecords",
  "Email",
  "Phone",
  "Postcode",
  "PatientRegistrationStatus",
  "DatePatientRegistration",
  "TrueNoTreatmentRecords"
),
range = "A6:R",
col_types = "DccccDcccTciccccTi"
)


# Read RefIgnore from the specified URL and sheet. It reads only a range of 'A1:A' from the sheet 'RefIgnore'.
# Since only one column is being read, it automatically infers that all entries are of type 'character'.
RefIgnore <- googlesheets4::range_read(
ss = SheetIDs$RefIgnore,
sheet = "RefIgnore",
range = "A1:A",
col_names = TRUE,
col_types = "c"
)

# Read PROMsMaster from the specified URL and sheet. It reads a range of 'D1:H' from the sheet 'PROMS Master list'.

PROMsMaster <- googlesheets4::range_read(
  ss = SheetIDs$PROMsMaster,
  sheet = "PROMS Master list",
  range = "D1:H",
  col_names = TRUE,
  col_types = "Dcicc") |> dplyr::select(-`External Reference`)



# read in existing Procedure Terms

TargetTerms2 <- googlesheets4::range_read(
  ss= SheetIDs$TargetTerms,
  sheet = "Procedures",
  range = "A1:C",
  col_names = TRUE,
  trim_ws = TRUE
) 
```

```{r}
#| label: Import-snapshot

# Get the latest snapshot file
latest_snapshot <- get_latest_snapshot()
# 
# You can then use these in your subsequent code:
temp_file <- tempfile(fileext = ".xlsx")
drive_download(
  file = latest_snapshot$snapshot$id,
  path = temp_file,
  overwrite = TRUE
)

SnapshotGen <- openxlsx2::read_xlsx(
  temp_file,
  sheet = "ShoulderGeneral",
  colNames = TRUE,
  detectDates = TRUE
  ) |> dplyr::mutate(
    Cohort = "General",
    across(starts_with("IC"),as.character)
  )

SnapshotRC <- openxlsx2::read_xlsx(
  temp_file,
  sheet = "RotatorCuff",
  colNames = TRUE,
  detectDates = TRUE
  ) |> dplyr::mutate(
    Cohort = "Rotator Cuff",
    across(starts_with("IC"),as.character)
  )

SnapshotGHI <- openxlsx2::read_xlsx(
  temp_file,
  sheet = "GlenohumeralInstability",
  colNames = TRUE,
  detectDates = TRUE
  ) |> dplyr::mutate(
    Cohort = "Glenohumeral Instability",
    across(starts_with("IC"),as.character)
  )

STROBEInput <- openxlsx2::read_xlsx(
  temp_file,
  sheet = "Strobe_Input",
  colNames = TRUE,
  detectDates = TRUE
  ) |> dplyr::mutate(
    Cohort = "Glenohumeral Instability"
  )

```

```{r}
#| label: Coerce-date

SnapshotDate <- lubridate::ymd(latest_snapshot$folder_name)

```

```{epoxy}
#| label: Declare-date

The snapshot date was {# Format to desired format using format()
FormattedDate <- format(SnapshotDate, "%d-%b-%Y")} and the report prepared {format(today(), "%d-%b-%Y")}. The imported data contains a dataframe of {nrow(SnapshotRC)} cases returned from the Rotator Cuff cohort, a dataframe of {nrow(SnapshotGHI)} cases returned from the Glenohumeral Instability cohort and a dataframe of {nrow(SnapshotGen)} cases from the General cohort. An additional dataframe was retrieved of {nrow(STROBEInput)} cases to generate the STROBE flow chart from the PRULO registry. 

```

## Combine and Filter for 3 month follow up

The dataset was filtered to only include records with a minimum of 3 months follow up at the time of analysis.

```{r}
## Slice inputs for columns and rows
#| label: Slice-stack-1
#| code-summary: "line up input frames"
#| warning: false

# Combine SnapshotRC, SnapshotGH, and SnapshotGen into a single table.
# Remove 'ExternalStudyTag', 'Email', and 'Phone' columns.
SnapshotComb <- SnapshotRC |> dplyr::select(-(c(ExternalStudyTag,Email,Phone))) |> 
  # Combine 'SnapshotGH' and 'SnapshotGen' tables with 'SnapshotRC' table by removing the specified columns.
  bind_rows(dplyr::select(SnapshotGHI, -(c(ExternalStudyTag,Email,Phone)))) |> 
  # Continue to combine tables by removing the specified columns. This time, combining 'SnapshotGen'.
  bind_rows(dplyr::select(SnapshotGen, -(c(ExternalStudyTag,Email,Phone)))) |> 
  # Create a new column 'PatientID' based on the TreatmentID column, using 'str_split_i' function with a pattern of '.'. This means splitting the string at the first occurrence of '.', and capturing the first part (using `1` argument).
  mutate(
        PatientID = str_split_i(TreatmentID,"\\.",1)
      ) |> 
  # Move 'PatientID' column before 'TreatmentID' column.
  relocate(
    PatientID, .before = TreatmentID
  ) |> 
  # Create a new column 'CombID' by pasting 'PatientID' and 'AffectedSide' columns.
  mutate(
    CombID = paste0(PatientID,AffectedSide)
  ) |> 
  # Move 'CombID' column after 'TreatmentID' column.
  relocate(
    CombID, .after = TreatmentID
  ) |> 
  # Move 'Cohort' column to the desired position in the table.
  relocate(
    Cohort, .before = EligibleAtPreop
  ) |> mutate(
  DurationTotal = as.numeric(as.duration(interval(ymd(DateTreatment), SnapshotDate)),"days")
  ) 

# Pause this filter - filter the index procedures with this, not the revisions
# |> filter(
#     DurationTotal > 89
#   )

```

## Prepare dataset for procedure

Procedure data was combined from all cohorts. New columns were created based on conditional statements, cases were filtered where procedure data was unavailable (non-surgical, missing intraoperative data). Procedure data was further processed to standardise labels, categorised by structure (Rotator Cuff, Labrum, Capsule and Ligament) and adjunct procedures reorganised to account for variation across surgical indication.

```{r}
#| label: snapshot-comb1

SnapshotComb1  <- SnapshotComb |> 
  # Use 'case_when' function to create CuffRepair2 column
  mutate(
    CuffRepair2 = case_when(
      CuffRepair == "Yes" ~ "Rotator Cuff Repair",  
      .default = NA_character_
    ),
    # Use 'str_detect' and 'str_to_lower' functions to create TreatmentGlenoid2 column
    TreatmentGlenoid2 = case_when(
      str_detect(str_to_lower(TreatmentGlenoid), "internal fixation") ~ "Glenoid internal fixation",
      !is.na(TreatmentGlenoid) & (TreatmentGlenoid != "None" | TreatmentGlenoid != "Internal fixation") ~ TreatmentGlenoid,
      .default = NA_character_
    ),
    # Use 'case_when' function to create AdjunctProcedures2 column
    AdjunctProcedures2 = case_when(
      !is.na(AdjunctProcedures) & AdjunctProcedures != "None performed" ~ AdjunctProcedures,
      .default = NA_character_
    )
  ) |> 
  # Use 'unite' function to concatenate the new columns into a single column called Procedures2
  unite(
    "Procedures2", 
    all_of(c(
      "CuffRepair2",
      "TreatmentGlenoid2",
      "TreatmentHumeralHead",
      "SoftTissueProcedure",
      "AdjunctProcedures2",
      "ProceduresOfInterest"
    )),
    sep = "; ", 
    remove = FALSE, 
    na.rm = TRUE
  ) |> 
  # Use 'relocate' function to move the Procedures2 column to the end of the dataframe
  relocate(
    Procedures2, 
    .after = last_col()
  ) |> dplyr::select(
    -CuffRepair
  )
```

```{r}
#
SnapshotCombProc <- SnapshotComb1  |> 
  # Use the 'filter' function from dplyr to apply a filter condition to the dataframe
  filter( 
    str_length(Procedures2)  > 0
  )
```

```{r}


# This code chunk uses the `unnest_regex` function from the tidytext package to expand and transform the Procedures2 column in the SnapshotCombProc dataframe
# The goal of this operation is likely to extract individual procedures from a comma-separated or semicolon-separated string, and create new rows for each procedure
# The input pattern specifies how to split the Procedures2 column into separate procedures

ProcedureMaster   <- tidytext::unnest_regex( 
  # Select specific columns from SnapshotCombProc dataframe
  SnapshotCombProc  |> dplyr::select(
    TreatmentID, 
    CombID, 
    DateTreatment, 
    AffectedSide, 
    TreatmentStatus, 
    TreatmentStatusNotes,
    Procedures2
   ),
  
  # Specify the output column name and the input column name
  output = Procedures3, 
  input = Procedures2,

  # Regular expression pattern to split the Procedures2 column into separate procedures
  pattern = "\\; |\\, |\\band\\b |\\+", 

  # Convert all procedure names to lowercase for consistency
  to_lower = TRUE,
  
  # Do not drop any rows during the transformation
  drop = FALSE
)
```

```{r}

# This code chunk selects and transforms the ProcedureMaster dataframe to create a new TargetTerms dataframe
# The goal of this operation is to identify unique target procedures (Procedures3) for each treatment UID, and store them in a Google Sheet

TargetTermsNew    <- ProcedureMaster |> 
  # Select only TreatmentID and Procedures3 columns
  dplyr::select(
    TreatmentID,
    Procedures3
  )   |> 
  # Remove duplicate rows while keeping all other columns (TreatmentID) using distinct()
  distinct(
    Procedures3, 
    .keep_all = TRUE
  )   |> 
  # Arrange the procedures in alphabetical order within each treatment UID
  arrange(
    Procedures3
  )   |> 
  # Use str_squish() to remove extra whitespace from procedure names
  mutate(
    Procedures3  = str_squish(Procedures3)
  )

# Commented out code: This is a call to the googlesheets4 package to write the TargetTerms dataframe to a Google Sheets spreadsheet

#googlesheets4::range_write(
#  ss = "https://docs.google.com/spreadsheets/d/1ESVvSKAv8ma11kri9pby6OEU9Gk5Z3UnF6XwjXBTcTg/edit", 
#  data = TargetTerms |> dplyr::select(TreatmentID, Procedures3), 
#  sheet = "Procedures", 
#  range = paste0("A1:", "B", nrow(TargetTerms) + 1),
#  col_names = TRUE
#)
```

```{r}
#| label: Procedure-master

# Create a new dataset by joining ProcedureMaster with TargetTerms2 on Procedures3
ProcedureMaster1 <- ProcedureMaster |> left_join(
  TargetTerms2 |> dplyr::select(-TreatmentID),
  by = "Procedures3",
  relationship = "many-to-many"
  ) |> 
  
  # Filter out rows with NA values in ReplaceProcedure and rows where ReplaceProcedure is "none"
  filter(!is.na(ReplaceProcedure), !(ReplaceProcedure == "none")) |> 
  
  # Group the data by TreatmentID
  group_by(TreatmentID) |> 
  
  # Remove duplicates while keeping all columns (including non-unique ones)
  distinct(ReplaceProcedure, .keep_all = TRUE) |> 
  
  # Filter out rows where ReplaceProcedure contains certain strings
  filter(str_detect(ReplaceProcedure, "slap|bankart|augment*", negate = TRUE)) |> 
  
  # Create a new column called Entry and order the data by this column
  mutate(Entry = str_order(ReplaceProcedure)) |> 
  
  # Arrange the data in descending order of Entry within each group
  arrange(desc(Entry), .by_group = TRUE) |> 
  ungroup()


# Create a new dataset by joining ProcedureMaster with TargetTerms2 on Procedures3
ProcedureMaster1a <- ProcedureMaster |> 
  left_join(
    TargetTerms2 |> dplyr::select(-TreatmentID),
    by = "Procedures3",
    relationship = "many-to-many"
  ) |> 
  
  # Filter out rows with NA values in ReplaceProcedure and rows where ReplaceProcedure is "none"
  filter(!is.na(ReplaceProcedure), !(ReplaceProcedure == "none")) |> 
  
  # Group the data by TreatmentID
  group_by(TreatmentID) |> 
  
  # Remove duplicates while keeping all columns (including non-unique ones)
  distinct(ReplaceProcedure, .keep_all = TRUE) |> 
  
  # Create a new column called Entry and order the data by this column
  mutate(Entry = str_order(str_sort(ReplaceProcedure))) |> 
  
  # Arrange the data in descending order of Entry within each group
  arrange(desc(Entry), .by_group = TRUE) |> 
  ungroup()
  

```

```{r}
#| label: fig-ProcedureCount
#| fig-cap: "Summary of procedure terms included in registry output"

# Create a new dataset by grouping ProcedureMaster1 by ReplaceProcedure and counting the occurrences
FigProcCount  <- ProcedureMaster1  |> 
  
   # Count the occurrences of each unique value in ReplaceProcedure, sort the results by count in ascending order (default), and create a new dataset
  count(ReplaceProcedure, sort = TRUE)  |> 
  
   # Filter out procedures with only one occurrence
  filter(n > 1)  |> 
  
   # Create a new column called ReplaceProcedure and reorder it based on the count of each procedure
  mutate(ReplaceProcedure = reorder(ReplaceProcedure, n))  |> 
  
   # Create a bar plot using ggplot2, where x-axis is the count (n) and y-axis is the reorder(replaceprocedure) variable
  ggplot(aes(n, ReplaceProcedure)) + 
  
   # Add a geom_col() layer to create the bar plot
  geom_col() + 
  
   # Remove the axis label for the y-axis using labs()
  labs(y = NULL)
  
  # Print the plot using knit_print from knitr package
knitr::knit_print(FigProcCount)
```

```{r}

# This is a data cleaning and processing script using the dplyr package in R. The script is designed to extract specific information from a column called Procedure4, which seems to contain descriptions of surgical procedures.

# Here's a high-level overview of what the script does:
# # 
# It creates new columns based on conditions detected in Procedure4. These conditions include:
# Rotator cuff repair and augmentation
# Long head biceps tendon repair, transfer, or tenotomy
# Labrum repair, debridement, or capsulolabral reconstruction
# Capsule ligament repair, release, or reconstruction
# Glenoid procedures (e.g., glenoplasty, Bristow, fixation)

# The script uses various str_detect and case_when functions to detect specific patterns in the Procedure4 column and assign corresponding values to the new columns.
# 
# Some conditions have multiple possible outcomes depending on the presence or absence of certain words or phrases in the Procedure4 description.

# Goal: Create a new data frame (ProcedureMaster2) that combines information from 
#       SnapshotComb1b and ProcedureMaster1a, and updates the RepairAugmentation column
#       to reflect more detailed information about augmentations in the Procedure4 column

ProcedureMaster2 <- left_join(
  # Filter SnapshotComb1 to only include rows with SurgicalTreatment == "Surgical"
  SnapshotComb1 |> filter(SurgicalTreatment == "Surgical") |>
  
  # Select specific columns from the filtered data frame
  dplyr::select(TreatmentID, CuffRepair2, AdjunctProcedures2, SoftTissueProcedure, RepairAugmentation, ProceduresOfInterest),
  
  # Summarize ProcedureMaster1a by TreatmentID and collapse unique ReplaceProcedure values into a single string separated by ";"
  summarise(ProcedureMaster1a, 
             .by = "TreatmentID", 
             Procedure4 = str_c(str_unique(ReplaceProcedure), collapse = "; ")
  ),
  
  # Specify the join relationship as one-to-one
  by = "TreatmentID",
  relationship = "one-to-one"
) |> 
  
#   This code chunk is building upon the previous one by continuing to transform and clean the `RepairAugmentation` column in the `ProcedureMaster2` data frame.
# 
# Here's a breakdown of what each line does:
# 
# 1. The first `mutate` statement creates a new column called `RepairAugmentation2`, which uses a series of conditional statements (`case_when`) to update the values in the original `RepairAugmentation` column based on conditions in the `Procedure4` column.
# 
#    - If `RepairAugmentation` is not NA or "Other" and `Procedure4` does not contain "augment*", then set `RepairAugmentation2` equal to the original value.
#    - If `RepairAugmentation` is NA or "Other" and `Procedure4` contains "augment*", then extract the text that follows "rotator cuff repair augmentation" (using a regular expression) and store it in `RepairAugmentation2`.
#    - If `RepairAugmentation` is not NA or "Other" and `Procedure4` contains "augment*", then concatenate the original value with the extracted text (from step 2) separated by "; ", and store the result in `RepairAugmentation2`.
# 
# 2. The second `mutate` statement creates a new column called `RepairAugmentation3`, which uses another series of conditional statements (`case_when`) to further transform the values in `RepairAugmentation2`. This includes:
#    - Replacing specific text patterns (e.g., "rotator cuff repair augmentation  - biceps") with alternative text ("Autograft").
#    - Replacing another specific text pattern (e.g., "rotator cuff repair augmentation  - superior capsular reconstruction") with a simpler term ("Superior Capsular").
#    - Adding the text "advancement" to `RepairAugmentation2` if it contains "advancement".
#    - Otherwise, just copying the original value.
# 
# 3. The third `mutate` statement creates a new column called `RepairAugmentationClean`, which uses yet another series of conditional statements (`case_when`) to clean up the values in `RepairAugmentation3`. This includes:
#    - Replacing a specific text pattern (e.g., "Superior Capsular; Superior Capsular") with a simpler term ("Superior Capsular").
#    - Setting "Nil" to "None" if that's what `RepairAugmentation3` is.
#    - Otherwise, just copying the original value.
# 
# These transformations aim to improve the readability and consistency of the data in the `RepairAugmentation` column.
  
  mutate(
  # Update RepairAugmentation column based on conditions in Procedure4 column
  RepairAugmentation2 = case_when(
    (!(is.na(RepairAugmentation)) | RepairAugmentation == "Other") & !str_detect(Procedure4, "augment*") ~ RepairAugmentation,
    (is.na(RepairAugmentation) | RepairAugmentation == "Other") & str_detect(Procedure4, "augment*") ~ str_extract(Procedure4, "rotator cuff repair augmentation\\s+([^;]+)"),
    (!(is.na(RepairAugmentation)) | RepairAugmentation != "Other") & str_detect(Procedure4, "augment*") ~ str_c(RepairAugmentation, str_extract(Procedure4, "rotator cuff repair augmentation\\s+([^;]+)"), sep = "; ")
  )
) |> mutate(
  RepairAugmentation3 = case_when(
    str_detect(RepairAugmentation2,"rotator cuff repair augmentation - biceps") ~ str_replace(RepairAugmentation2,"rotator cuff repair augmentation - biceps", "Autograft"),
        str_detect(RepairAugmentation2,"rotator cuff repair augmentation - superior capsular reconstruction") ~ str_replace(RepairAugmentation2,"rotator cuff repair augmentation - superior capsular reconstruction", "Superior Capsular"),
    str_detect(Procedure4,"advancement") ~ str_c(RepairAugmentation2,"advancement",sep = "; "),
    .default = RepairAugmentation2
    )
  ) |> mutate(
    RepairAugmentationClean = case_when(
      str_detect(RepairAugmentation3,"Superior Capsular; Superior Capsular") ~ str_replace(RepairAugmentation3,"Superior Capsular; Superior Capsular","Superior Capsular"),
      RepairAugmentation3 == "Nil" ~ "None",
      .default = RepairAugmentation3
      )
    ) |> mutate(
      CuffRepair = case_when(
        !is.na(RepairAugmentationClean) & RepairAugmentationClean != "None" & str_detect(Procedure4,"rotator cuff repair") ~ "Augmented Cuff Repair",
        (is.na(RepairAugmentationClean) | RepairAugmentationClean == "None") & str_detect(Procedure4,"rotator cuff repair") ~ "Cuff Repair",
        str_detect(Procedure4,"remplissage") ~ "Remplissage",
        !is.na(Procedure4) & str_detect(Procedure4, "(rotator cuff repair)|remplissage", negate = TRUE) ~ "None",
        .default = NA_character_
      ),
      LongHeadBiceps = case_when(
        str_detect(Procedure4,"biceps tenodesis") ~ "Tenodesis",
        str_detect(Procedure4,"biceps transfer") ~ "Transfer",
        str_detect(Procedure4, "tenotomy") ~ "Tenotomy",
        str_detect(Procedure4, "long-head") ~ "Unknown",
        !is.na(Procedure4) & str_detect(Procedure4, "(biceps)(tenotomy|transfer|tenodesis)", negate = TRUE) ~ "None",
        .default = NA_character_
      ),
      Labrum = case_when(
        str_detect(Procedure4,"labrum repair") ~ "Labrum Repair",
        str_detect(Procedure4,"labrum debridement") ~ "Debridement",
        str_detect(Procedure4, "capsulolabral") ~ "Capsulolabral Repair",
        !is.na(Procedure4) & str_detect(Procedure4, "((labrum repair)|debridement)|capsulolabral", negate = TRUE) ~ "None",
        .default = NA_character_
      ),
            LabrumRepair = case_when(
        str_detect(Procedure4,"bankart") ~ "Bankart",
        str_detect(Procedure4,"slap") ~ "SLAP",
        str_detect(Procedure4,"labrum repair") & str_detect(Procedure4, "bankart|slap", negate = FALSE) ~ "Other",
        !is.na(Procedure4) & str_detect(Procedure4, "((labrum repair)|debridement)|capsulolabral", negate = TRUE) ~ "None",
        .default = NA_character_
      ),
      CapsuleLigament = case_when(
        str_detect(Procedure4,"shift") ~ "Capsular Shift",
        str_detect(Procedure4,"(ligament|avulsion) repair") ~ "Repair",
        str_detect(Procedure4,"ligament (debulk|release|debridement)") ~ "Ligament Release",
        str_detect(Procedure4, "capsulotomy") ~ "Capsulotomy",
        str_detect(Procedure4, "capsular reconstruction") | str_detect(RepairAugmentationClean, "Capsular") ~ "Capsular Reconstruction",
        str_detect(Procedure4, "other soft tissue") ~ "Other",
        !is.na(Procedure4) & str_detect(Procedure4, "shift|capsulotomy|release|soft((ligament|avulsion)(repair))", negate = TRUE) & str_detect(RepairAugmentationClean, "Capsular", negate = TRUE) ~ "None",
        .default = NA_character_
      ),
      Glenoid = case_when(
        str_detect(Procedure4,"glenoplasty") ~ "Glenoplasty",
        str_detect(Procedure4,"bristow") ~ "Bristow",
        str_detect(Procedure4,"fixation") & str_detect(Procedure4,"humeral fracture", negate = TRUE) ~ "Fracture fixation",
        str_detect(Procedure4,"latarjet") ~ "Latarjet",
        !is.na(Procedure4) & (str_detect(Procedure4, "glenoplasty|fixation|latarjet|bristow", negate = TRUE) | str_detect(Procedure4,"humeral fracture")) ~ "None",
        .default = NA_character_
      )
      )
```

```{r}

# Filter out adjunct procedures from proceduremaster and then left_join into proceduremaster2

ProcedureAdjunct <- ProcedureMaster1 |> dplyr::select(-Entry) |> filter(
  str_detect(
    ReplaceProcedure,
    "repair|remplissage|biceps|labrum|capsul*|ligament|soft|gleno*|fixation|latarjet|bristow",
    negate = TRUE)
) |> group_by(
  TreatmentID
) |> distinct(
  ReplaceProcedure,
  .keep_all = TRUE
) |> mutate(
  Entry = str_order(
  ReplaceProcedure
) 
) |> arrange(
  desc(ReplaceProcedure),
  .by_group = TRUE
) |> ungroup()

```

```{r}

# Continue processing to extract out adjunct procedures and reinject back into procedures dataframe
ProcedureMaster3 <- left_join(
  ProcedureMaster2,
  summarise(
  ProcedureAdjunct,
  .by = "TreatmentID",
  AdjunctProcedure = str_c(str_unique(ReplaceProcedure), collapse = "; ")
),
by = "TreatmentID"
) |> mutate(
  AdjunctProcedure2 = stringr::str_to_title(case_when(
   if_any(CuffRepair:Glenoid,~!is.na(.)) & is.na(AdjunctProcedure) ~ "None", 
    if_all(CuffRepair:Glenoid,~is.na(.)) ~ NA_character_,
    .default = AdjunctProcedure
  )
)
) |> mutate(
  across(
    c(
      CuffRepair,
      LongHeadBiceps,
      Labrum,
      CapsuleLigament
      ),
      ~ifelse(. == "None", NA, .))
  ) |> unite(
    "ProcedureTotal",
    c(CuffRepair, LongHeadBiceps, Labrum, CapsuleLigament),
    na.rm = TRUE,
    sep = "; ",
    remove = FALSE
    ) |> mutate(
      ProcedureTotal = ifelse(ProcedureTotal == "", "None", ProcedureTotal)
  ) |> dplyr::select(
  -(c(
    AdjunctProcedure,
    RepairAugmentation,
    RepairAugmentation2,
    RepairAugmentation3
  )
  )
) |> rename(
  AdjunctProcedure = "AdjunctProcedure2",
  RepairAugmentation = "RepairAugmentationClean"
) |> relocate(
  RepairAugmentation,
  .after = CuffRepair
) |> mutate( # switch back to "None" labeling for tables in each report
  across(
    c(
      CuffRepair,
      LongHeadBiceps,
      Labrum,
      CapsuleLigament
      ),
      ~ifelse(is.na(.), "None", .))
  )
```

```{r}

# Marry into SnapshotComb to continue processing from one dataframe
#Adjust for labrum procedures

SnapshotComb1a <- left_join(
  SnapshotComb1 |> dplyr::select(
    -(c(
      AdjunctProcedures,
      RepairAugmentation,
      TreatmentGlenoid,
      TreatmentHumeralHead
    ))
    ),
    ProcedureMaster3 |> dplyr::select(
      TreatmentID,
      ProcedureTotal:AdjunctProcedure
    ),
    by = "TreatmentID",
    relationship = "one-to-one"
  ) |> separate_wider_delim(
  cols = LabralTearPosition,
  delim = " - ",
  names = c("TearStart","TearEnd")
) |> mutate(
  TearStart = as.numeric(TearStart),
  TearEnd = as.numeric(TearEnd),
  LabrumPath2 = case_when(
    is.na(TearStart) | is.na(TearEnd) ~ NA_character_,
    (!is.na(TearStart) & !is.na(TearEnd)) & (between(TearStart,1,6) & between(TearEnd,3.9,10)) ~ "Bankart",
    (!is.na(TearStart) & !is.na(TearEnd)) & (between(TearStart,6.1,11.9) & between(TearEnd,6.1,11.9)) ~ "Posterior",
    (!is.na(TearStart) & !is.na(TearEnd)) & (between(TearStart,9.9,12.9) | between(TearStart,0.9,2.1)) & (between(TearEnd,9.9,12.9) | between(TearEnd,0.9,2.1)) ~ "SLAP",
    .default = "Other"
  )
) |> mutate(
  LabrumRepair2 = case_when(
    str_detect(Labrum,"Repair") & LabrumPath2 == "Bankart" ~ "Bankart",
    str_detect(Labrum,"Repair") & LabrumPath2 == "SLAP" ~ "SLAP",
    str_detect(Labrum,"Repair") & LabrumPath2 == "Other" ~ "Other",
    str_detect(Labrum,"Repair") & LabrumPath2 == "SLAP" ~ "SLAP",
    str_detect(Labrum,"Repair") & LabrumPath2 == "Posterior" ~ "Posterior",
    !is.na(LabrumPath2) & (is.na(Labrum)|Labrum == "None") ~ "Not Repaired",
    .default = LabrumRepair
    )
  ) |> relocate(
  c(TearStart,TearEnd,LabrumPath2), .after = "Procedures2"
)   |> relocate(
  c(LabrumRepair2), .after = "LabrumRepair"
) |> dplyr::select(
  -LabrumRepair
) |> rename(
  LabrumRepair = "LabrumRepair2"
)
```

## Adjust dataset for time to event

To account for variations in follow up, time to event was calculated between date of surgery and change of record status. Treatment record end was defined as any change in state such that the treatment would be considered no longer active, has not achieved its clinical purpose or is no longer relevant. For example, in the case of soft tissue repair, if the target tissue represents with a retear, or the construct presents in a state such that hardware removal or replacement is recommended, then the treatment record status is set to inactive and a new treatment record is created to capture the subsequent treatment. The treatments with inactive statuses were extracted to a shared file for review. The subsequent treatment was manually labelled to create the *Subsequent Treatment* variable.

Additional numeric variables were calculated from inputs collected within the registry (e.g. Symptom Duration).

```{r}
#| label: Survival-prep-1
# create endate and survival time

#Calculate status
SnapshotComb2 <- SnapshotComb1a |> mutate(
  Status = case_when(
    TreatmentStatus == "Failed"~ 1,
    .default = 0),
  EndDate = case_when(
    !is.na(DateStatusChange) ~ DateStatusChange,
    .default = coalesce(DateStatusChange, SnapshotDate)
  ),
  Duration = as.numeric(as.duration(interval(ymd(DateTreatment), ymd(EndDate))),"weeks"),
        WaitTime = as.numeric(as.duration(interval(ymd(DateInitialExamination), ymd(DateTreatment))),"weeks"),
 CuffTearSizeML = as.numeric(CuffTearSizeML),
 CuffTearSizeAP = as.numeric(CuffTearSizeAP),
 SymptomDuration = as.numeric(as.duration(interval(ymd(DateOfInjury_Preop), ymd(DateTreatment))),"weeks"),
 SymptomDurationCat = case_when(
  is.na(SymptomDuration) ~ NA_character_,
  SymptomDuration <= 26 ~ "<=0.5",
  SymptomDuration > 26 ~ ">0.5"
) 
 )


SnapshotCombFail <- SnapshotComb2 |> dplyr::filter(
  TreatmentStatus == "Failed",
  SurgicalTreatment == "Surgical"
)

# |> dplyr::mutate(
#   factor(levels = c("<=0.5", ">0.5"), exclude = NULL)
```

```{r}
#| eval: false

# Authenticate for sheets using the same token
gs4_auth(token = drive_token())

with_gs4_quiet(googlesheets4::range_write(
  ss = SheetIDs$AuditResults,
  data = SnapshotCombFail |> dplyr::select(
    TreatmentID,
    CombID,
    DateTreatment,
    Cohort,
    TreatmentStatus,
    TreatmentStatusNotes,
    DateStatusChange
    ) |> dplyr::arrange(
     desc(DateTreatment)
    ),
  sheet = "Failures",
  range = "A1:G",
  col_names = TRUE
)
)
```

Read in results of manual review of failure cases and categorise subsequent treatments.

```{r}

SnapshotSubseq <- SnapshotComb2 |> dplyr::filter(
  CombID %in% SnapshotCombFail$CombID
) |> dplyr::select(
  TreatmentID,
  CombID,
  DateTreatment,
  TreatmentStatus,
  TreatmentStatusNotes,
  DateStatusChange,
  SurgicalTreatment
) |> dplyr::group_by(
  CombID
) |> arrange(
  CombID,
  DateTreatment,
  by_group = FALSE
)


```

```{r}
#| eval: true

# Authenticate for sheets using the same token
gs4_auth(token = drive_token())

SnapshotRevision <- googlesheets4::range_read(
  ss = SheetIDs$AuditResults,
  sheet = "Failures",
  range = "A1:H",
  col_types = "ccDcccDc"
)


```


```{r}

SnapshotComb2a <- left_join(
  SnapshotComb2,
  SnapshotRevision |> dplyr::select(
    TreatmentID,
    SubsequentTx
  ),
  by = "TreatmentID"
) |> mutate(
  SubsequentTx2 = case_when(
    is.na(SubsequentTx) ~ "Not Applicable",
    str_detect(SubsequentTx,"ROH") ~ str_replace_all(SubsequentTx,"ROH","Removal of Hardware"),
    str_detect(SubsequentTx,"Non-op") ~ "Nonoperative Management",
    .default = stringr::str_to_title(SubsequentTx)
  ),
    ReoperationProcedure2 = case_when(
      is.na(ReoperationProcedure) & (SubsequentTx2 == "Nonoperative Management" | SubsequentTx2 == "Not Applicable")  ~ "No",
      is.na(ReoperationProcedure) & !(SubsequentTx2 == "Nonoperative Management" | SubsequentTx2 == "Not Applicable") ~ "Yes",
      ReoperationProcedure == "No" & !(SubsequentTx2 == "Nonoperative Management" | SubsequentTx2 == "Not Applicable") ~ "Yes",
      .default = ReoperationProcedure
    )
)
```

```{r}
SnapshotCombCheck <- SnapshotComb2a |> dplyr::select(
  TreatmentID,
  Cohort,
  TreatmentStatus,
  TreatmentStatusNotes,
  ReoperationProcedure2,
  SubsequentTx
)
```

## Prepare patient group of interest

Tables were rearranged and the dataset was filtered for cases receiving the hardware of interest.

```{r}
#| label: strobe-input
#| code-summary: "CONSORT|STROBE"


# Inclusion
# - Surgical treatment
# - With hardware of interest
# After "induction"
# - Patient withdraws consent
# - Treatment fails before analysis date
# - Not eligible for 3m followup
# 

STROBEFlow <- STROBEInput |> dplyr::filter(
  !is.na(TreatmentID)
) |> dplyr::left_join(
  SnapshotComb1 |> dplyr::select(
    TreatmentID,
    CombID,
    DateInitialExamination,
    EligibleAtPreop,
    EligibleAtx3months
  ),
  by = "TreatmentID"
) |> dplyr::mutate(
  DurationTotal = as.numeric(as.duration(interval(ymd(DateTreatment), ymd(SnapshotDate))),"days"),
  exclusion1 = case_when(
    is.na(SurgicalTreatment) ~ "Not a surgical treatment",
    SurgicalTreatment == "Surgical" ~ NA_character_,
    .default = "Not a surgical treatment"
  ),
  induction = if_else(
    !is.na(exclusion1),
    NA_character_,
    TreatmentID
  ),
  exclusion2 = case_when(
    !is.na(induction) & stringr::str_detect(RegistryStatus,"Opt-out") ~ "Patient Opt-Out",
    !is.na(induction) & stringr::str_detect(ImplantCodes,"05.10.002") ~ NA_character_,
    (!is.na(induction) & stringr::str_detect(ImplantCodes,"05.10.002", negate = TRUE)) | (!is.na(induction) & is.na(ImplantCodes)) ~ "No hardware of interest"
  ),
  followup = if_else(
    !is.na(induction) & is.na(exclusion2),
    TreatmentID,
    NA_character_
  ),
  arm3 = if_else(
    !is.na(followup),
    RegistryCohortName,
    NA_character_
  ),
  lost_followup = case_when(
    !is.na(induction) & is.na(exclusion2) & is.na(EligibleAtx3months) & TreatmentStatus == "Failed" & (ymd(DateStatusChange) < ymd(SnapshotDate)) ~ "Repair failure",
    !is.na(induction) & is.na(exclusion2) & is.na(EligibleAtx3months) & TreatmentStatus == "No further followup" & (ymd(DateStatusChange) < ymd(SnapshotDate)) ~ "Patient Opt-out",
    !is.na(induction) & is.na(exclusion2) & TreatmentStatus == "Ongoing" & is.na(EligibleAtx3months) ~ "Not eligible for followup"
  ),
  mitt = if_else(
    !is.na(followup) & is.na(lost_followup),
    TreatmentID,
    NA_character_
)
) |> dplyr::rename(
  trialno = "TreatmentID"
)


```


Reduce to master table and adjust sex for report presentation

```{r}
#| label: master-list


MasterTable <- SnapshotComb2a |> filter(
  TreatmentID %in% STROBEFlow$followup
) |> mutate(
  Sex2 = case_when(
    Sex == "F" ~ "Female",
    Sex == "M" ~ "Male",
    .default = NA_character_
  )
) |> dplyr::select(-Sex) |> rename(
  Sex = "Sex2"
)


```




## Prepare Patient-Reported Outcomes

The PRULO registry uses the QuickDASH [@gummesson2006] for all cases, Western Ontario Rotator Cuff Index (WORC) [@kirkley2003] for records placed into the Rotator Cuff cohort and the Western Ontario Shoulder Instability Index (WOSI) [@kirkley1998] for records placed in the Glenohumeral Instability cohort to monitor patient-reported outcomes before and after surgery at defined time intervals. The metrics utilised for each questionnaire in this report are the total score (QuickDaSH) and the normalised total score (WORC and WOSI). PROMs entries were restricted to cases where the treatment record was "eligible" for the time point. Tables were reshaped and variables refactored, with delta variables generated (difference to baseline at each followup) to enable plotting and table generation.

```{r}
#| label: Proms-prep
#| code-summary: "Prepare for PROMs analysis"
#| warning: false

#Add delta columns Pre-3months; Pre-6months; Pre-12months

MasterPROM <- MasterTable |>
  rename_with( ~sub("_TotalScore_","",.), contains("TotalScore")) |>
  rename_with( ~sub("WOSI_Norm_","WOSINorm",.), contains("WOSI_Norm")) |>
  rename_with( ~sub("WORC_Norm_","WORCNorm",.), contains("WORC_Norm")) |>
  rename_with( ~sub("PhysicalQ3_","PhysicalQ3",.), contains("PhysicalQ3")) |>
  rename_with( ~sub("EligibleAt|EligibleAtx", "Eligible",.), starts_with("EligibleAt")) |>
  mutate(
  across(matches("QDASH|WORC|WOSI"),as.numeric)
  ) |>
  dplyr::select(
    !c(
    RegistryStatus:DateOfBirth, 
    DominantSide, 
    Weight,
    Height,
    DateBMI,
    EligibleIntraop,
    RecordNumberInIntraop,
    tidyselect::ends_with("24months")
    )
    ) |>
  relocate((all_of(c("QDASHPreop",
                        "QDASH3months",
                        "QDASH6months",
                        "QDASH12months",
                        "EligiblePreop",
                        "Eligible3months",
                        "Eligible6months",
                        "Eligible12months"))), .after = last_col(),
           ) |>
mutate(
  Eligible3months = case_when(
    Eligible3months != "Yes" ~ NA_character_,
    .default = Eligible3months
  ),
  DeltaQPreop = NA,
  DeltaQ3months = case_when(
    (EligiblePreop == "Yes" & !is.na(QDASHPreop)) & (Eligible3months == "Yes" & !is.na(QDASH3months)) ~ QDASHPreop - QDASH3months,
    .default = NA
  ),
   DeltaQ6months = case_when(
    (EligiblePreop == "Yes" & !is.na(QDASHPreop)) & (Eligible6months == "Yes" & !is.na(QDASH6months)) ~ QDASHPreop - QDASH6months,
    .default = NA
  ),
   DeltaQ12months = case_when(
    (EligiblePreop == "Yes" & !is.na(QDASHPreop)) & (Eligible12months == "Yes" & !is.na(QDASH12months)) ~ QDASHPreop - QDASH12months,
    .default = NA
  ),
  WORCDeltaPreop = NA,
  WORCDelta6months = case_when(
    (EligiblePreop == "Yes" & !is.na(WORCNormPreop)) & (Eligible6months == "Yes" & !is.na(WORCNorm6months)) ~ WORCNorm6months - WORCNormPreop,
    .default = NA
  ),
   WORCDelta12months = case_when(
    (EligiblePreop == "Yes" & !is.na(WORCNormPreop)) & (Eligible12months == "Yes" & !is.na(WORCNorm12months)) ~ WORCNorm12months - WORCNormPreop,
    .default = NA
  ),
  WOSIDeltaPreop = NA,
  WOSIDelta3months = case_when(
    (EligiblePreop == "Yes" & !is.na(WOSINormPreop)) & (Eligible3months == "Yes" & !is.na(WOSINorm3months)) ~ WOSINormPreop - WOSINorm3months - WOSINormPreop,
    .default = NA
  ),
  WOSIDelta6months = case_when(
    (EligiblePreop == "Yes" & !is.na(WOSINormPreop)) & (Eligible6months == "Yes" & !is.na(WOSINorm6months)) ~ WOSINorm6months - WOSINormPreop,
    .default = NA
  ),
   WOSIDelta12months = case_when(
    (EligiblePreop == "Yes" & !is.na(WOSINormPreop)) & (Eligible12months == "Yes" & !is.na(WOSINorm12months)) ~ WOSINorm12months - WOSINormPreop,
    .default = NA
  ),
  )

```

```{r}
# Check the lengths of columns specified in varying



QDASH_cols <- grep("QDASH", colnames(MasterPROM), value = TRUE)
DeltaQ_cols <- grep("DeltaQ", colnames(MasterPROM), value = TRUE)
WORC_cols  <- grep("WORCNorm|WORCPhysicalQ3|WORCDelta", colnames(MasterPROM), value = TRUE)
WOSI_cols  <- grep("WOSINorm|WOSIDelta", colnames(MasterPROM), value = TRUE)
Eligible_cols <- grep("Eligible", colnames(MasterPROM), value = TRUE)

lengths_QDASH <- sapply(QDASH_cols, function(col) length(unique(MasterPROM$TreatmentID)))
lengths_DeltaQ <- sapply(DeltaQ_cols, function(col) length(unique(MasterPROM$TreatmentID)))
lengths_WORC <- sapply(WORC_cols, function(col) length(unique(MasterPROM$TreatmentID)))
lengths_WOSI <- sapply(WOSI_cols, function(col) length(unique(MasterPROM$TreatmentID)))

lengths_Eligible <- sapply(Eligible_cols, function(col) length(unique(MasterPROM$TreatmentID)))

```

```{r}
#| label: PROM-prep-DASHWOSI

MasterPROM1 <- MasterPROM |>
  pivot_longer(
    cols = c(
      starts_with("QDASH"),
      starts_with("DeltaQ"),
      starts_with("WOSINorm"),
      starts_with("WOSIDelta"),
      starts_with("Eligible")
    ),
    names_to = c(".value", "Timepoint"),
    names_pattern = "(.+)(Preop|3m|6m|12m)",
    values_to = c("QDASH", "QDASHDelta", "WOSINorm", "WOSIDelta", "Eligible")
  ) |>
  mutate(Timepoint = forcats::fct(
    Timepoint, 
    levels = c("Preop", "3m", "6m", "12m"))
    ) |> filter(!is.na(Eligible)) |> rename(
      QDASHDelta = "DeltaQ"
    )

```

## Prepare adverse events

Adverse events were monitored by near real-time chart review and surgical bookings. Events were added to the registry using an electronic form and linked to the treatment records. The data import was assessed for data entry validity, differences between date of event, date of reoperation and surgery date of the index treatment were calculated to assess date validity. Additional data preparation and cleaning was performed, which included filtering and standardizing key identifiers across multiple datasets. Missing values were identified to ensure data consistency. The adverse events were attached to the treatment data with filters applied to constrain to pertinent records and time periods. Time-based metrics were calculated and classification was performed based on the event descriptions using regular expressions. Finally, it conducted data quality checks, identifying potential discrepancies and duplicate entries. After the data transformation, the revised dataset was exported to an external file for review. The code then generated multiple subset datasets, each focusing on a specific type of complication and isolating the earliest occurrence for each unique treatment. This was used for retrieval for each product report.

```{r}
#| label:  Complications-intraop
# Slice out intraoperative complications (explants)
# 
# 
IntraopComp <- MasterTable |> dplyr::select(
  TreatmentID,
  CombID,
  DateTreatment,
  SurgicalTreatment,
  TreatmentStatus,
  ICCount:ICIntervention
) |> filter(
  !is.na(ICCount)
) |> mutate(
  ICNature2 = if_else(
    stringr::str_detect(ICNature,"explant"),
    "Hardware explantation",
    ICNature
  )
)

```

```{r}
#| label:  Complications-postop
# Join sufficient columns to complictable to perform calculations


# Add filter to align complications table with snapshot with CurrentDate
ComplicTable1 <- ComplicTable |> dplyr::filter(
    `Date of Occurrence` < SnapshotDate
    ) |>
  mutate(
    TreatmentID = trimws(`Treatment ID`)
  )

#Tidy up TreatmentID in both tables
# Remove leading and trailing whitespaces

SnapshotComb2a$TreatmentID <- trimws(SnapshotComb2a$TreatmentID)
# Check data types
#str(ComplicTable1$TreatmentID)
#str(SnapshotComb2$TreatmentID)

#str(SnapshotComb2$DateTreatment)

# Check for NAs in ComplicTable1
na_in_ComplicTable1 <- sum(is.na(ComplicTable1$TreatmentID))


# Check for NAs in SnapshotMerge2
na_in_SnapshotComb2a <- sum(is.na(SnapshotComb2a$TreatmentID))

```



<!--# Clean up live tables for complications. Assess date validity and correct data entry. -->

```{r}
mismatched_rows <- ComplicTable1[!(ComplicTable1$TreatmentID %in% MasterTable1$TreatmentID), ]

# Remove non-matching rows from ComplicTable2
ComplicTable2 <- ComplicTable1 |>
  filter(!(TreatmentID %in% mismatched_rows$TreatmentID))
```

```{r}
# Join in key data from Snapshot table to calculate additional columns
ComplicTable3 <- left_join(
  ComplicTable2,
  SnapshotComb2a |> dplyr::select(
  TreatmentID,
  DateStatusChange,
  DateTreatment,
  ICCount:ICIntervention
  ),
  by = "TreatmentID"
) |> 
  filter(
    !is.na(DateTreatment) & `Complication Occurrence` != "No"
  ) |>
  mutate(
    DateOccurFix = ymd(`Date of Occurrence`),
  ) |>
mutate(
  EventDelay = as.numeric(as.duration(interval(ymd(DateTreatment), ymd(DateOccurFix))),"weeks"), # Mitek would like this in years - may need to change over once intiial review is complete
  ReopDelay_Surgery = as.numeric(difftime(`Reoperation Procedure Date`,DateTreatment,units = "weeks")),
  ReopDelay_Occur = as.numeric(difftime(`Reoperation Procedure Date`,DateOccurFix,units = "weeks")),
DateCheck = case_when(
  `Date of Occurrence` < DateTreatment ~ "Check",
  .default = "OK"
),
  Infection = case_when(
    stringr::str_detect(stringr::str_to_lower(`Complication Nature`),"washout|infect|antibiotic*|vac.*dress*|culture") ~ "Yes", #added "culture" as term for Infection
    .default = "No",
  ),
  Ligament_Tendon = case_when(
    stringr::str_detect(stringr::str_to_lower(`Complication Nature`),"fail|recurrent|rupture|retear|.*torn|weak|weakness|tear") ~ "Yes", #removed enthesopathy, as those kind of connective tissue pathologies will make it difficult to distinguish from retears in this framework - pushed to Other. 
    .default = "No"
    ),
  Stiffness = case_when(
    stringr::str_detect(stringr::str_to_lower(`Complication Nature`),"capsulitis|frozen|stiff*|release|arthrofib*") ~ "Yes", #removed "carpal tunnel release" as a term for "Stiffness" as it was previously overlapping with other types of releases
    .default = "No"
    ),
  Loosening = case_when(
   stringr::str_detect(stringr::str_to_lower(`Complication Nature`),"regraft*|loos(?!e\\sbodies)|pullout") ~ "Yes",
    .default = "No"
    ),
  Hardware = case_when(
   stringr::str_detect(stringr::str_to_lower(`Complication Nature`),"remov*|irritat*|explant*|broke*|annoy*|device|replac*") ~ "Yes", 
   .default = "No"
  ),
  Instability = case_when(stringr::str_detect(stringr::str_to_lower(`Complication Nature`),"instab*|sublux*|disloc*") ~ "Yes",
    .default = "No"
  ),
  Neurological = case_when(
    stringr::str_detect(stringr::str_to_lower(`Complication Nature`),"palsy|radiculopathy|carpal\\s+tunnel") ~ "Yes", #added carpal tunnel compression or release as a potential neurological condition
    .default = "No"
  ),
  Fracture = case_when(
    stringr::str_detect(stringr::str_to_lower(`Complication Nature`),"fract*") ~ "Yes",
    .default = "No"
  ),
  Wound = case_when(
    stringr::str_detect(stringr::str_to_lower(`Complication Nature`),"wound|necro*") ~ "Yes",
    .default = "No"
  ),
  Thrombosis = case_when(
    stringr::str_detect(stringr::str_to_lower(`Complication Nature`),"dvt|embo*|\\bpe\\b|occlus*") ~ "Yes",
    .default = "No"
  ),
  Effusion = case_when(
    stringr::str_detect(stringr::str_to_lower(`Complication Nature`),"swell*|edema|oedema|effus*|swollen") ~ "Yes",
    .default = "No"
  ),
  Pain = case_when(
    stringr::str_detect(stringr::str_to_lower(`Complication Nature`),"pain|complex|crps") ~ "Yes", #previously had word boundary - but got excluded when hard up against ";" so removed word boundaries
    .default = "No"
  )
) |>
  rowwise() |>
  mutate(
    Other = case_when(
      any(str_detect(c_across(Infection:Pain),"Yes")) ~ "No",
      .default = "Yes"
    ),
    PainIsol = case_when(
      any(str_detect(c_across(Infection:Effusion),"Yes")) | Other == "Yes" ~ "No",
      all(str_detect(c_across(Infection:Effusion),"No")) & Other == "No" & Pain == "Yes" ~ "Yes",
      .default = NA_character_
    )
  )
```

```{r}
#| label: complication-check

ComplicFailCheck <- ComplicTable3 |> filter(
  !is.na(DateStatusChange)
) |> mutate(
  StatusDiff = ymd(DateStatusChange) - ymd(`Date of Occurrence`)
) |> relocate(
  StatusDiff,
  .after = DateStatusChange
) |> group_by(
  TreatmentID
) |> slice_max(
  `Date of Occurrence`
)

```

```{r}
#| label: Write-complications
#| eval: false


with_gs4_quiet(googlesheets4::range_write(
  ss = SheetIDs$AuditResults,
  data = ComplicTable3,
  sheet = "ComplicTable",
  range = "A1:AN",
  col_names = TRUE
)
)
```

Split out into arrays to bounce against for each Product report

```{r}

ComplicInfection <- ComplicTable3 |> dplyr::group_by(TreatmentID) |> filter(Infection == "Yes") |> slice_min(DateOccurFix, n = 1) |> ungroup()
ComplicLigament_Tendon <- ComplicTable3 |> group_by(TreatmentID) |> filter(Ligament_Tendon == "Yes") |> slice_min(DateOccurFix, n = 1) |> ungroup()
ComplicStiffness <- ComplicTable3 |> group_by(TreatmentID) |> filter(Stiffness == "Yes") |> slice_min(DateOccurFix, n = 1) |> ungroup()
ComplicLoosening <- ComplicTable3 |> group_by(TreatmentID) |> filter(Loosening == "Yes") |> slice_min(DateOccurFix, n = 1) |> ungroup()
ComplicHardware <- ComplicTable3 |> group_by(TreatmentID) |> filter(Hardware == "Yes" & Loosening == "No") |> slice_min(DateOccurFix, n = 1) |> ungroup()
ComplicInstability <- ComplicTable3 |> group_by(TreatmentID) |> filter(Instability == "Yes") |> slice_min(DateOccurFix, n = 1) |> ungroup()
ComplicNeurological <- ComplicTable3 |> group_by(TreatmentID) |> filter(Neurological == "Yes") |> slice_min(DateOccurFix, n = 1) |> ungroup()
ComplicFracture <- ComplicTable3 |> group_by(TreatmentID) |> filter(Fracture == "Yes") |> slice_min(DateOccurFix, n = 1) |> ungroup()
ComplicThrombosis <- ComplicTable3 |> group_by(TreatmentID) |> filter(Thrombosis == "Yes") |> slice_min(DateOccurFix, n = 1) |> ungroup()
ComplicEffusion <- ComplicTable3 |> group_by(TreatmentID) |> filter(Effusion == "Yes") |> slice_min(DateOccurFix, n = 1) |> ungroup()
ComplicPain <- ComplicTable3 |> group_by(TreatmentID) |> filter(PainIsol == "Yes") |> slice_min(DateOccurFix, n = 1) |> ungroup()
ComplicOther <- ComplicTable3 |> group_by(TreatmentID) |> filter(Other == "Yes") |> slice_min(DateOccurFix, n = 1) |> ungroup()
ComplicReop <- ComplicTable3 |> group_by(TreatmentID) |> filter(`Reoperation Procedure` == "Yes") |> slice_min(DateOccurFix, n = 1) |> ungroup()


```

<!--# Review intraoperative complications manually for mechanism -->

Intraoperative complications were reviewed manually for mechanism.

```{r}
#| label: Complication-discrepancies
#| eval: false

ComplicDiscrep <- ComplicTable3 |> filter(
  DateCheck == "Check"|
    is.na(`Complication Nature`)|
    (`Reoperation Procedure` == "Yes" & `Complication Occurrence` == "No")
)

#Identify duplicate entries
ComplicDiscrep2 <- ComplicTable3 |>
  group_by(TreatmentID, DateOccurFix) |>
  filter(n() > 1)

# Identify the problematic codes that are not linking back to the ProductTable correctly

with_gs4_quiet(googlesheets4::range_write(
  ss = SheetIDs$AuditResults,
  data = bind_rows(ComplicDiscrep,ComplicDiscrep2) |> arrange(TreatmentID),
  sheet = "ComplicDiscrepancy",
  range = "A1:AN",
  col_names = TRUE
)
)


```

```{r}
#| label: Complications-missing
#| eval: false

# Comment out after first use
 # range_write(ComplicTable4,
 #             ss = "https://docs.google.com/spreadsheets/d/1e7431oSrK9tItiSZb4wCWPI7nqGqawH8pNgnqgHPNkU/edit",
 #             sheet = "ComplicDiscrepancy2",
 #             range = "A1:AC")

 with_gs4_quiet(range_write(MasterTable1 |>
               filter(SurgicalTreatment == "Surgical" & is.na(ComplicationOccurrence)) |>
               dplyr::select(TreatmentID,DateTreatment),
             ss = SheetIDs$AuditResults,
             sheet = "ComplicMissing",
            range = "A1:C")
 )
```

# PRULO Summary

The diagram below summarises recruitment and categorisation of patients into the PRULO registry.



```{r}
#| label: fig-strobe
#| fig-cap: "Flowchart of data extraction and case selection up to 3 months followup across each cohort"
#| eval: true



STROBEPlot <- consort::consort_plot(
  data = STROBEFlow,
  orders = c(
    trialno = "Population",
    exclusion1 = "Excluded",
    induction = "Received Surgery",
    exclusion2 = "Excluded from Sample",
    followup = "Received JLock anchor",
    arm3 = "Diagnostic Group",
    lost_followup = "Unavailable 3m",
    mitt = "Final Analysis"),
side_box = c(
  "exclusion1",
  "exclusion2",
  "lost_followup"
  ),
allocation = "arm3",
cex = 0.7,
kickoff_sidebox = TRUE
)

knitr::knit_print(STROBEPlot)
```






```{r}
#| label: tbl-diagnosis
#| tbl-cap: "Summary of diagnoses using ICD-10 coding for primary presentation"

DiagnosisData <- MasterTable1  |> mutate(
    ICD10 = stringr::str_extract(DiagnosisPrimary,"^[A-Za-z]+[0-9.]+")
  )

TableData <- DiagnosisData |> group_by(
           Cohort
           ) |> count(
             ICD10, 
             sort = TRUE
             ) |> slice_head(n = 5) 

knitr::kable(TableData)


```


The overall registry enrolment is summarised in @tbl-surgical, describing how the population is summarised into cohorts.

# Product Report - JLock

## Overview

Usage of the Product within the patient group is summarised below.

```{epoxy}
#| label:  Overview-Rep

{
  if(nrow(MasterTable1) == 1) {
    epoxy::epoxy("There is {nrow(MasterTable1)} case involving the anchor of interest.")
  } else {
    procedures <- unique(MasterTable1$ProcedureTotal)
    procedures <- procedures[procedures != "None" & procedures != "Unknown" & procedures != ""]
    procedures <- procedures[!grepl("^(Tenodesis|Tenotomy)$", procedures)]
    
    procedures_string <- if(length(procedures) > 1) {
  result1 <- paste(procedures[-length(procedures)], collapse = "] [")
  paste0(result1, "], and [", procedures[length(procedures)])
    } else {
      procedures
    }
    
    epoxy::epoxy("There are {nrow(MasterTable1)} cases involving the anchor of interest. Surgeries were performed between {format(min(MasterTable1$DateTreatment),'%Y-%b-%d')} and {format(max(MasterTable1$DateTreatment),'%Y-%b-%d')}. The procedures included [{procedures_string}].")
  }
}

```

## Procedure Report - All

```{r}
#| label: Slice-stack-2


MasterTable1 <- MasterTable |> mutate(
    CuffStatus2 = case_when(
      is.na(CuffStatus) & !is.na(PatientPosition) ~ "Intact",
      !is.na(CuffStatus) ~ CuffStatus,
      .default = NA_character_
    ),
  Infection = TreatmentID %in% ComplicInfection$TreatmentID,
  Ligament_Tendon = TreatmentID %in% ComplicLigament_Tendon$TreatmentID,
  Stiffness = TreatmentID %in% ComplicStiffness$TreatmentID,
  Loosening = TreatmentID %in% ComplicLoosening$TreatmentID,
  Hardware = TreatmentID %in% ComplicHardware$TreatmentID,
  Instability = TreatmentID %in% ComplicInstability$TreatmentID,
  Neurological = TreatmentID %in% ComplicNeurological$TreatmentID,
  Fracture = TreatmentID %in% ComplicFracture$TreatmentID,
  Thrombosis = TreatmentID %in% ComplicThrombosis$TreatmentID,
  Effusion = TreatmentID %in% ComplicEffusion$TreatmentID,
  Pain = TreatmentID %in% ComplicPain$TreatmentID,
  Other = TreatmentID %in% ComplicOther$TreatmentID,

  Reop = TreatmentID %in% ComplicReop$TreatmentID
) |> left_join(
  ComplicTable3 |> group_by(TreatmentID) |> slice_max(`Reoperation Procedure Date`, n = 1) |> ungroup() |> dplyr::select(
    TreatmentID,
    ReopDelay_Occur,
    ReopDelay_Surgery,
    EventDelay
  ),
  by = "TreatmentID"
) |> dplyr::distinct( #maybe have a look at this in the future, its a duplicate complication coming across I think 506.1
  TreatmentID,
  .keep_all = TRUE
)
```

### Patient Characteristics

Patient demographic, pathology, and treatment characteristics for this cohort receiving the Product are summarised below.

```{r}
#| label: tbl-demographics
#| tbl-cap: "Summary of PRULO Report JLock (All) - Patient Characteristics"

TableRep <-
  MasterTable1 |> mutate(
    SurgeonA = case_when(
      Surgeon == "KE" ~ "A",
      Surgeon == "RP" ~ "B",
      Surgeon == "GB" ~ "C",
      .default = NA_character_
  )) |>
  dplyr::select(
    AgeAtInitialExam,
    Sex,
    Cohort,
    IndexSide,
    BilateralStatus,
    SymptomDuration,
    SymptomDurationCat,
    #SurgeonA,
    #LongHeadBiceps,
    TreatmentStatus,
    RegistryStatus,
    Cohort
    ) |>
    tbl_summary(
      #by = LongHeadBiceps,
      label = list(
        #SurgeonA ~ "Surgeon",
        AgeAtInitialExam ~ "Age at Initial Consultation (Years)",
        Sex = "Male",
        BilateralStatus ~ "Bilateral Presentation",
        IndexSide ~ "Dominant Side",
        SymptomDuration ~ "Symptom Duration (Weeks)",
        SymptomDurationCat ~ "Symptom Duration Category",
        TreatmentStatus ~ "Treatment Record Active",
        RegistryStatus ~ "Patient Record Active"
      ),
      type = list(
        AgeAtInitialExam ~ "continuous",
        SymptomDuration ~ "continuous",
        Sex ~ "dichotomous",
        TreatmentStatus ~ "dichotomous",
        RegistryStatus ~ "dichotomous"
      ),
      value = list(
        Sex = "Male",
        IndexSide = "Dominant",
        TreatmentStatus = "Ongoing",
        RegistryStatus = "Open"
      ),
      statistic = list(
        all_categorical() ~ "{p} ({n})"
        ),
      by = "Cohort",
      missing = "no"
    ) |> add_overall() |> add_stat_label(
    location = "column"
  ) |> modify_table_styling(
      columns = label,
      rows = label == "Symptom Duration Category",
      footnote = "Dichotomised below or equal to 0.5 years or greater than 0.5 years"
  ) |> modify_table_styling(
      columns = label,
      rows = label == "Treatment Record Active",
      footnote = "Treatment record remains active - no change to follow up"
  ) |> modify_table_styling(
      columns = label,
      rows = label == "Patient Record Active",
      footnote = "Patient record remains open - no change to consent or mortality status"
  ) 

gtsummary::as_flex_table(TableRep) |> flextable::set_table_properties(
  layout = "autofit",
  width = 0.5,
  align = "center",
  opts_word = list(
    split = TRUE
    )
)

```

### Surgical Details

Surgical findings and management strategies are summarised below.

```{r}
#| label: tbl-pathsurg
#| tbl-cap: "Summary of PRULO Report (JLock) Cases Pathology and Surgical Details"


TableRep2 <-
  MasterTable1 |>
  dplyr::select(
    CuffStatus2,
    TreatmentType,
    # ProductCountFct, #This has a code block it depends on to derive this count within the dataframe - ensure its copied|amended into each report as required
    CuffRepair:AdjunctProcedure) |>
  tbl_summary(
      #by = LongHeadBiceps,
      label = list(
        CuffStatus2 ~ "Cuff Status",
        TreatmentType ~ "Treatment Type"
      ),
      statistic = list(
        all_categorical() ~ "{p} ({n})"
        ),
      missing = "no"
    ) |> modify_table_styling(
      columns = label,
      rows = label == "Other",
      footnote = "Labral tear uncategorised"
    ) 

gtsummary::as_flex_table(TableRep2) |> flextable::set_table_properties(
  layout = "autofit",
  width = 0.5,
  align = "center",
  opts_word = list(
    split = TRUE
    )
)
```

### Treatment Survival

```{epoxy}
#| label:  Duration


The mean follow up duration is {round(MasterTable1 |> ungroup() |> summarise(mean = mean(Duration))/52,1)} years, with a standard deviation of {round(MasterTable2 |> ungroup() |> summarise(sd = sd(Duration))/52,2)} years.

```

Failure or revision events as identified in the registry for this cohort are summarised below. Individual failure data can be accessed in [Attachment 1](https://docs.google.com/spreadsheets/d/https://docs.google.com/spreadsheets/d/1ESVvSKAv8ma11kri9pby6OEU9Gk5Z3UnF6XwjXBTcTg/edit).

```{r}
#| label: tbl-procsurvival
#| tbl-cap: "Summary of PRULO Report (JLock) Cases - Procedure Survival"

TableRep3 <- tbl_survfit(
  survfit2(Surv(Duration, Status) ~ 1, 
           data = MasterTable1),
  times = c(1,26,52,104),
  label_header = "**{time} Weeks**",
  label = "Procedure Survival",
  statistic = "{estimate} ({conf.low} - {conf.high})"
) |> gtsummary::modify_footnote_header(
    footnote = "% survival with 95% confidence intervals",
    columns = all_stat_cols(),
  )

gtsummary::as_flex_table(TableRep3) |> flextable::set_table_properties(
  layout = "autofit",
  width = 0.5,
  align = "center",
  opts_word = list(
    split = TRUE
    )
)

```

```{r}
#| label:  Failure-Report-1

#Previous surgery(ies) at the same site Anatomical Location 
#Anchor 1 Anchor 2 Anchor 3 Anchor 4

FailuresRep <-
  MasterTable1 |> mutate(
    TreatmentStatusDesc = stringr::str_to_sentence(TreatmentStatusNotes)
  ) |>
      filter(TreatmentStatus == "Failed") |> 
  dplyr::select(
    TreatmentID,
    AgeAtInitialExam, 
    Sex,
    TreatmentType,
    Duration,
    TreatmentStatusDesc,
    ReoperationProcedure2,
    SubsequentTx2,
    QDASH_TotalScore_Preop,
    QDASH_TotalScore_3months,
    QDASH_TotalScore_6months) |> mutate(
      Procedure = "All"
    ) |> arrange(
      TreatmentID
    )

```

```{epoxy}
#| label: Failure-Report-2
#| eval: false

{ifelse(nrow(FailuresRep) == 0,
        epoxy::epoxy("There are no failures or revisions to report."),
       with_gs4_quiet(googlesheets4::range_write(
         ss = SheetIDs$AuditReport,
         data = FailuresRep |> arrange(TreatmentID),
         sheet = "Failures1",
         range = "A1:P",
         col_names = TRUE
         )
       )
)
  }


```

### Adverse Events

Complications and adverse events are summarised below. Individual reoperation data can be accessed in [Attachment 1](https://docs.google.com/spreadsheets/d/1ESVvSKAv8ma11kri9pby6OEU9Gk5Z3UnF6XwjXBTcTg/edit#gid=0).

```{r}
#| label: IntraopComp - Rep


# Check if any Count value is greater than zero in filtered data
has_complications <- MasterTable1 |> 
  filter(TreatmentID %in% IntraopComp$TreatmentID) |> 
  nrow() > 0

# Conditionally set chunk options and generate table
if (has_complications == 0) {
  # If no rows, return the text message
  epoxy("No intraoperative complications observed.")
} else {
  knitr::opts_current$set(
    label = "tbl-intraop-complications-6",
    tbl.cap = "Summary of PRULO Report 6 (All) Cases - Intraoperative Events"
  )
  
  IntraopComp |> filter(
    TreatmentID %in% MasterTable2$TreatmentID
  ) |> rename(
    Description = "ICNature2",
    Intervention = "ICIntervention",
    PostopManagement = "ICPostopManagement"
  ) |> select(
    TreatmentID,
    Description,
    Intervention,
    PostopManagement
    ) |> gt::gt()
}
```

```{r}
#| label:  Complication-Other-Rep


MasterTableOther <- MasterTable1 |> filter(
  Other == TRUE
) |> dplyr::select(
  TreatmentID,
  DateTreatment,
  Cohort
)
```

```{r}
#| label: tbl-TableRep4
#| tbl-cap: "Summary of PRULO Report (JLock) Cases - Postoperative Events"

# Now create the summary table
TableRepPC <- MasterTable1 |>
  dplyr::select(
    Infection,
    Ligament_Tendon,
    Effusion,
    Pain,
    Hardware,
    Loosening,
    Instability,
    Stiffness,
    Neurological,
    Thrombosis,
    Other,
    Reop,
    SubsequentTx2, #Inserted to address C028
    ReopDelay_Surgery) |>
  tbl_summary(
    label = list(
      Ligament_Tendon ~ "Ligament|Tendon (Retear)",
      ReopDelay_Surgery ~ "Reoperation Delay (Weeks)",
      Reop ~ "Reoperation",
      SubsequentTx2 ~ "Subsequent Treatment"
      ),
    type = list(
      ReopDelay_Surgery ~ "continuous"
    ),
    statistic = list(
      all_categorical() ~ "{p} ({n})",
      all_continuous() ~ "{mean} ({sd})"
    ),
    missing = "no",
    digits = list(
      all_continuous() ~ 1,
      all_categorical() ~ 0)
    ) |> modify_table_styling (
      columns = label,
      rows = label == "Subsequent Treatment",
      footnote = "Management undertaken for procedures that have suffered tissue failure or required hardware removal or replacement"
    ) |> modify_table_styling(
      columns = label,
      rows = label == "Reoperation",
      footnote = "A theatre procedure subsequent to the index surgery that does not involve removal, replacement or modification of the construct."
    ) |> modify_table_styling(
      columns = label,
      rows = label == "Reoperation Delay (Weeks)",
      footnote = "Time between index procedure and reoperation"
    ) 

gtsummary::as_flex_table(TableRepPC) |> flextable::set_table_properties(
  layout = "autofit",
  width = 0.5,
  align = "center",
  opts_word = list(
    split = TRUE
    )
)
```

```{r}
#| label: Reoperations-Report-1

#echo: false
#warning: false

#Previous surgery(ies) at the same site Anatomical Location 
#Anchor 1 Anchor 2 Anchor 3 Anchor 4

##Flip this around so that multiple reoperations are retained


MasterTableReop <- ComplicTable3 |> filter(
  TreatmentID %in% MasterTable2$TreatmentID,
  `Reoperation Procedure` == "Yes"
  ) |> group_by(TreatmentID) |> slice_min(
    ReopDelay_Surgery,
    n = 1
    ) |> ungroup() |> left_join(
      MasterTable1 |> dplyr::select(
    TreatmentID,
    AgeAtInitialExam,
    Sex,
    TreatmentType,
    QDASH_TotalScore_Preop,
    QDASH_TotalScore_3months,
    QDASH_TotalScore_6months
      ),
    by = "TreatmentID",
    relationship = "one-to-one"
    ) |>
  mutate(
     QDASH_TotalScore_Preop = as.numeric(QDASH_TotalScore_Preop),
     QDASH_TotalScore_3months = as.numeric(QDASH_TotalScore_3months),
     QDASH_TotalScore_6months =as.numeric(QDASH_TotalScore_6months)
  ) |> dplyr::select(
    TreatmentID,
    AgeAtInitialExam,
    Sex,
    TreatmentType,
    `Complication Nature`,
    QDASH_TotalScore_Preop,
    QDASH_TotalScore_3months,
    QDASH_TotalScore_6months
  ) |> mutate(
    Procedure = "All"
    ) |> arrange(
    TreatmentID
    )

```

Write reoperations to external sheet

```{epoxy}
#| label: Reoperations-Report-2
#| eval: false



{ifelse(nrow(MasterTable2Reop) == 0,
        epoxy::epoxy("There are no reoperations to report."),
       with_gs4_quiet(googlesheets4::range_write(
         ss = SheetIDs$AuditReport,
         data = MasterTable2Reop,
         sheet = "Reoperations1",
         range = "A1:P",
         col_names = TRUE
         )
       )
)
  }



```

### Patient-Reported Outcomes

Complete case analysis of QDASH and WOSI Index Normalised is summarised below.

```{r}
#| label: fig-PROMRep6
#| fig-cap: "Complete case analysis of QDASH(Top), WOSI Index (Bottom)"


RepPROM1 <- ggplot(data = MasterPROM1, mapping = aes(Timepoint,QDASH)) + 
geom_boxplot()

RepPROM2 <- ggplot(data = MasterPROM1, mapping = aes(Timepoint,WOSINorm)) + 
geom_boxplot()

RepPROM1 / RepPROM2

```

```{r}
#| label: tbl-TableRep65
#| tbl-cap: "Summary of PRULO Report (JLock) Cases - QuickDASH"


TableRepPROM <- MasterPROM1 |>
dplyr::select(
  QDASH,
  QDASHDelta,
  WOSINorm,
  WOSIDelta,
  Timepoint) |>
tbl_summary(by = "Timepoint",
            missing = "no",
            type = list(
              QDASH ~ "continuous",
              QDASHDelta ~ "continuous",
              WOSINorm ~ "continuous",
              WOSIDelta ~ "continuous"
            ),
            statistic = all_continuous() ~ "{median} ({p25} - {p75})"
            )

gtsummary::as_flex_table(TableRepPROM) |> flextable::set_table_properties(
  layout = "autofit",
  width = 0.7,
  align = "center",
  opts_word = list(
    split = TRUE
    )
)


```



